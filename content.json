{"meta":{"title":"Ares","subtitle":"技术不容易，一步一步往前走","description":null,"author":"Ares","url":"http://www.xxzp.tech","root":"/"},"pages":[{"title":"About","date":"2018-08-28T02:42:13.000Z","updated":"2018-08-28T02:42:13.000Z","comments":false,"path":"about/index.html","permalink":"http://www.xxzp.tech/about/index.html","excerpt":"","text":"本博客主要为博主学习笔记与总结，如有侵权或疑问请以邮件联系博主。 email: ares012@sina.com"},{"title":"categories","date":"2018-09-01T09:00:09.000Z","updated":"2018-09-01T09:22:10.000Z","comments":true,"path":"categories/index.html","permalink":"http://www.xxzp.tech/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-09-01T09:03:22.000Z","updated":"2018-11-02T10:31:35.490Z","comments":false,"path":"tags/index.html","permalink":"http://www.xxzp.tech/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"java服务线上问题排查思路","slug":"java服务线上问题排查思路","date":"2018-10-09T16:00:00.000Z","updated":"2018-10-10T01:40:40.859Z","comments":true,"path":"2018/10/10/java服务线上问题排查思路/","link":"","permalink":"http://www.xxzp.tech/2018/10/10/java服务线上问题排查思路/","excerpt":"1. 常见问题Java 服务的线上问题从系统表象来看归结起来总共有四方面：CPU、内存、磁盘、网络，可以分为两大类： 系统问题：CPU 使用率过高、CPU 上下文切换频率次数较高、磁盘空间不够、磁盘 I/O 频繁、网络流量异常、系统可用内存过低等 业务问题：PV 量过高、服务调用耗时异常、线程死锁、多线程并发问题、频繁进行 Full GC等","text":"1. 常见问题Java 服务的线上问题从系统表象来看归结起来总共有四方面：CPU、内存、磁盘、网络，可以分为两大类： 系统问题：CPU 使用率过高、CPU 上下文切换频率次数较高、磁盘空间不够、磁盘 I/O 频繁、网络流量异常、系统可用内存过低等 业务问题：PV 量过高、服务调用耗时异常、线程死锁、多线程并发问题、频繁进行 Full GC等 2. 问题定位思路一边从操作系统开始，先排除操作系统和网络问题而导致的线上服务问题，这些问题可以很快从系统的监控工具看到。进而关注 jvm 相关参数，而这一步相对来说比较难排查。下面从系统问题和业务问题角度去分析一下常用的排查命令。 2.1 系统问题排查关注点：cpu、内存、网络、磁盘 常用命令: top/htop: 显示当前系统正在执行的进程的相关信息，包括进程ID、内存占用率、CPU占用率等 -b: 批处理 -c: 显示完整的治命令 -I: 忽略失效过程 -s: 保密模式 -S: 累积模式 -i&lt;时间&gt;: 设置间隔时间 -u&lt;用户名&gt;: 指定用户名 -p&lt;进程号&gt;: 指定进程 -n&lt;次数&gt;: 循环显示的次数 free: 显示当前系统未使用的和已使用的内存数目，还可以显示被内核使用的内存缓冲区 vmstat: 详细的内存、cpu、进程、I/O等系统整体运行状态Procs: r: 运行队列中进程数量，这个值也可以判断是否需要增加CPU。（长期大于1） b: 等待IO的进程数量。 Memory: swpd: 使用虚拟内存大小，如果swpd的值不为0，但是SI，SO的值长期为0，这种情况不会影响系统性能。 free: 空闲物理内存大小。 buff: 用作缓冲的内存大小。 cache: 用作缓存的内存大小，如果cache的值大的时候，说明cache处的文件数多，如果频繁访问到的文件都能被cache处，那么磁盘的读IO bi会非常小。 Swap: si: 每秒从交换区写到内存的大小，由磁盘调入内存。 so: 每秒写入交换区的内存大小，由内存调入磁盘。 IO: bi: 每秒读取的块数 bo: 每秒写入的块数 system: in: 每秒中断数，包括时钟中断。 cs: 每秒上下文切换数。 CPU： us: 用户进程执行时间百分比(user time)。us的值比较高时，说明用户进程消耗的CPU时间多，但是如果长期超50%的使用，那么我们就该考虑优化程序算法或者进行加速。 sy: 内核系统进程执行时间百分比(system time)。sy的值高时，说明系统内核消耗的CPU资源多，这并不是良性表现，我们应该检查原因。 wa: IO等待时间百分比。wa的值高时，说明IO等待比较严重，这可能由于磁盘大量作随机访问造成，也有可能磁盘出现瓶颈（块操作）。 id: 空闲时间百分比 iostat: 系统输入输出设备和CPU的使用情况，统计磁盘活动统计情况，同时也会汇报出CPU使用情况 lsof: 查看进程开打的文件，打开文件的进程，进程打开的端口，同时可找回/恢复删除的文件 -a：列出打开文件存在的进程； -c&lt;进程名&gt;：列出指定进程所打开的文件； -g：列出GID号进程详情； -d&lt;文件号&gt;：列出占用该文件号的进程； +d&lt;目录&gt;：列出目录下被打开的文件； +D&lt;目录&gt;：递归列出目录下被打开的文件； -n&lt;目录&gt;：列出使用NFS的文件； -i&lt;条件&gt;：列出符合条件的进程 -p&lt;进程号&gt;：列出指定进程号所打开的文件； -u：列出UID号进程详情； -h：显示帮助信息； -v：显示版本信息。 示例： 1lsof -i:8080 #查看8080端口的进程 dstat: 系统信息统计工具 -c：显示CPU系统占用，用户占用，空闲，等待，中断，软件中断等信息。 -C：当有多个CPU时候，此参数可按需分别显示cpu状态，例：-C 0,1 是显示cpu0和cpu1的信息。 -d：显示磁盘读写数据大小。 -D hda,total：include hda and total。 -n：显示网络状态。 -N eth1,total：有多块网卡时，指定要显示的网卡。 -l：显示系统负载情况。 -m：显示内存使用情况。 -g：显示页面使用情况。 -p：显示进程状态。 -s：显示交换分区使用情况。 -S：类似D/N。 -r：I/O请求情况。 -y：系统状态。 –ipc：显示ipc消息队列，信号等信息。 –socket：用来显示tcp udp端口状态。 -a：此为默认选项，等同于-cdngy。 -v：等同于 -pmgdsc -D total。 –output file：可以把状态信息以csv的格式重定向到指定的文件中。 pstack: 打印输出此进程的堆栈信息。可以输出所有线程的调用关系栈。 pstree:以树状图的方式展现进程之间的派生关系，显示效果比较直观。 -a：显示每个程序的完整指令，包含路径，参数或是常驻服务的标示。 -c：不使用精简标示法。 -G：使用VT100终端机的列绘图字符。 -h：列出树状图时，特别标明现在执行的程序。 -H：此参数的效果和指定”-h”参数类似，但特别标明指定的程序。 -l：采用长列格式显示树状图。 -n：用程序识别码排序。预设是以程序名称来排序。 -p：显示程序识别码。 -u：显示用户名称。 -U：使用UTF-8列绘图字符。 -V：显示版本信息。 strace: 是一个集诊断、调试、统计与一体的工具，我们可以使用strace对应用的系统调用和信号传递的跟踪结果来对应用进行分析 -c 统计每一系统调用的所执行的时间,次数和出错的次数等. -d 输出strace关于标准错误的调试信息. -f 跟踪由fork调用所产生的子进程. -ff 如果提供-o filename,则所有进程的跟踪结果输出到相应的filename.pid中,pid是各进程的进程号. -F 尝试跟踪vfork调用.在-f时,vfork不被跟踪. -h 输出简要的帮助信息. -i 输出系统调用的入口指针. -q 禁止输出关于脱离的消息. -r 打印出相对时间关于,,每一个系统调用. -t 在输出中的每一行前加上时间信息. -tt 在输出中的每一行前加上时间信息,微秒级. -ttt 微秒级输出,以秒了表示时间. -T 显示每一调用所耗的时间. -v 输出所有的系统调用.一些调用关于环境变量,状态,输入输出等调用由于使用频繁,默认不输出. -V 输出strace的版本信息. -x 以十六进制形式输出非标准字符串 -xx 所有字符串以十六进制形式输出. -a column 设置返回值的输出位置.默认 为40. -e expr 指定一个表达式,用来控制如何跟踪.格式：[qualifier=][!]value1[,value2]…qualifier只能是 trace,abbrev,verbose,raw,signal,read,write其中之一.value是用来限定的符号或数字.默认的 qualifier是 trace.感叹号是否定符号.例如:-eopen等价于 -e trace=open,表示只跟踪open调用.而-etrace!=open 表示跟踪除了open以外的其他调用.有两个特殊的符号 all 和 none. 注意有些shell使用!来执行历史记录里的命令,所以要使用\\. -e trace=set 只跟踪指定的系统 调用.例如:-e trace=open,close,rean,write表示只跟踪这四个系统调用.默认的为set=all. -e trace=file 只跟踪有关文件操作的系统调用. -e trace=process 只跟踪有关进程控制的系统调用. -e trace=network 跟踪与网络有关的所有系统调用. -e strace=signal 跟踪所有与系统信号有关的 系统调用 -e trace=ipc 跟踪所有与进程通讯有关的系统调用 -e abbrev=set 设定strace输出的系统调用的结果集.-v 等与 abbrev=none.默认为abbrev=all. -e raw=set 将指定的系统调用的参数以十六进制显示. -e signal=set 指定跟踪的系统信号.默认为all.如 signal=!SIGIO(或者signal=!io),表示不跟踪SIGIO信号. -e read=set 输出从指定文件中读出 的数据.例如: -e read=3,5 -e write=set 输出写入到指定文件中的数据. -o filename 将strace的输出写入文件filename -p pid 跟踪指定的进程pid. -s strsize 指定输出的字符串的最大长度.默认为32.文件名一直全部输出. -u username 以username的UID和GID执行被跟踪的命令 netstat: 用于显示各种网络相关信息 -a：列出所有当前的连接 -at： -t 列出 TCP 协议的连接 -au： -u 列出 UDP 协议的连接 -ant：-n 禁用域名解析功能 -tnl： -l 列出正在监听的套接字 -nlpt：查看进程信息 -ltpe：-ep 查看进程名和用户名 -s：列出所有网络包的统计情况 -rn：-r 选项打印内核路由信息 -i： 打印网络接口信息 -ie：同上，与ifconfig类似 -ct：-c 选项持续输出信息 -g：-g 会输出 IPv4 和 IPv6 的多播组信息 2.2 业务异常排查思路：线程状态 –&gt; gc log –&gt; 堆 –&gt; 业务log, 其中 full gc 相对比较明显，而线程状态主要查询是否有 locked等。线程状态： jstack:(详细参数查看) gc 信息： jstat:(详细参数查看) jmap:(详细参数查看)","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://www.xxzp.tech/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.xxzp.tech/tags/jvm/"},{"name":"gc","slug":"gc","permalink":"http://www.xxzp.tech/tags/gc/"}]},{"title":"jvm 自带命令工具","slug":"java常用命令","date":"2018-09-24T16:00:00.000Z","updated":"2018-09-26T15:03:31.931Z","comments":true,"path":"2018/09/25/java常用命令/","link":"","permalink":"http://www.xxzp.tech/2018/09/25/java常用命令/","excerpt":"1. jpsjava程序在启动以后，会在 java.io.tmpdir 指定的目录下，就是临时文件夹里，生成 /tmp/hsperfdata_{userName}/），这个目录下会放着所有对 java 进程的 pid。 1234567jps -hillegal argument: -husage: jps [-help] jps [-q] [-mlvV] [&lt;hostid&gt;]Definitions: &lt;hostid&gt;: &lt;hostname&gt;[:&lt;port&gt;]","text":"1. jpsjava程序在启动以后，会在 java.io.tmpdir 指定的目录下，就是临时文件夹里，生成 /tmp/hsperfdata_{userName}/），这个目录下会放着所有对 java 进程的 pid。 1234567jps -hillegal argument: -husage: jps [-help] jps [-q] [-mlvV] [&lt;hostid&gt;]Definitions: &lt;hostid&gt;: &lt;hostname&gt;[:&lt;port&gt;] 参数说明： jps -q: 仅显示 pid jps -v: 输出传递给JVM的参数 jps -m: 输出传递给main 方法的参数，在嵌入式jvm上可能是null jps -l: 输出应用程序main class的完整package名 或者 应用程序的jar文件完整路径名 2. jstackjstack 用于生成 java 虚拟机当前时刻的线程快照。线程快照是当前 java 虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等。 线程状态: NEW: 未启动的，不会出现在Dump中 RUNNABLE: 在虚拟机内执行的 BLOCKED: 受阻塞并等待监视器锁 WAITING: 无限等待另一个线程执行特定操作 TIMED_WAITING: 有时限等待另一个线程的特定操作 TERMINATED: 线程执行完成状态 12345678910111213141516jstack -hUsage: jstack [-l] &lt;pid&gt; (to connect to running process) jstack -F [-m] [-l] &lt;pid&gt; (to connect to a hung process) jstack [-m] [-l] &lt;executable&gt; &lt;core&gt; (to connect to a core file) jstack [-m] [-l] [server_id@]&lt;remote server IP or hostname&gt; (to connect to a remote debug server)Options: -F to force a thread dump. Use when jstack &lt;pid&gt; does not respond (process is hung) -m to print both java and native frames (mixed mode) -l long listing. Prints additional information about locks -h or -help to print this help message 参数说明： jstack pid: 查看堆栈信息 jstack -F pid: 强制打印栈信息 jstack -m pid: 打印 java 和 native c/c++ 所有栈信息 jstack -l pid: 打印关于锁的附加信息 3. jmapjmap 主要打印指定Java进程的共享对象内存映射或堆内存细节，可以使用 jmap 生成 Heap Dump。Heap Dump 是反应 Java 堆使用情况的内存镜像，其中主要包括系统信息、虚拟机属性、完整的线程Dump、所有类和对象的状态等。 1234567891011121314151617181920212223242526272829jmap -hUsage: jmap [option] &lt;pid&gt; (to connect to running process) jmap [option] &lt;executable &lt;core&gt; (to connect to a core file) jmap [option] [server_id@]&lt;remote server IP or hostname&gt; (to connect to remote debug server)where &lt;option&gt; is one of: &lt;none&gt; to print same info as Solaris pmap -heap to print java heap summary -histo[:live] to print histogram of java object heap; if the \"live\" suboption is specified, only count live objects -clstats to print class loader statistics -finalizerinfo to print information on objects awaiting finalization -dump:&lt;dump-options&gt; to dump java heap in hprof binary format dump-options: live dump only live objects; if not specified, all objects in the heap are dumped. format=b binary format file=&lt;file&gt; dump heap to &lt;file&gt; Example: jmap -dump:live,format=b,file=heap.bin &lt;pid&gt; -F force. Use with -dump:&lt;dump-options&gt; &lt;pid&gt; or -histo to force a heap dump or histogram when &lt;pid&gt; does not respond. The \"live\" suboption is not supported in this mode. -h | -help to print this help message -J&lt;flag&gt; to pass &lt;flag&gt; directly to the runtime system 参数说明: jmap pid: 打印共享对象映射，将会打印目标虚拟机中加载的每个共享对象的起始地址、映射大小以及共享对象文件的路径全称 jmap -heap pid: 打印一个堆的摘要信息，包括使用的GC算法、堆配置信息和 堆使用信息(各分内存区域信息) jmap -histo pid: 打印堆的统计信息，其中包括每个Java类、对象数量、内存大小(单位：字节)、完全限定的类名 jmap -histo:live pid: 同上，只计算活动的对象, 会触发 full gc jmap clstats: 打印类加载统计信息 jmap finalizerinfo pid: 打印等待终结的对象信息 jmap dump format=b, file=filename pid: 以 hprof 二进制格式转储 Java 堆到指定 filename 的文件中。 jmap dump:live, format=b,file=ilename pid: 同上，只输出活跃对象信息 jmap -F pid: 强制模式，如果指定的pid没有响应，请使用jmap -dump 或jmap -histo 选项，不支持live子选项。 4. jstatjstat(JVM Statistics Monitoring Tool)用于监控虚拟机各种运行状态信息的命令行工具，可用于显示本地或远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据 123456789101112131415161718192021jstat -helpUsage: jstat -help|-options jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]Definitions: &lt;option&gt; An option reported by the -options option &lt;vmid&gt; Virtual Machine Identifier. A vmid takes the following form: &lt;lvmid&gt;[@&lt;hostname&gt;[:&lt;port&gt;]] Where &lt;lvmid&gt; is the local vm identifier for the target Java virtual machine, typically a process id; &lt;hostname&gt; is the name of the host running the target Java virtual machine; and &lt;port&gt; is the port number for the rmiregistry on the target host. See the jvmstat documentation for a more complete description of the Virtual Machine Identifier. &lt;lines&gt; Number of samples between header lines. &lt;interval&gt; Sampling interval. The following forms are allowed: &lt;n&gt;[\"ms\"|\"s\"] Where &lt;n&gt; is an integer and the suffix specifies the units as milliseconds(\"ms\") or seconds(\"s\"). The default units are \"ms\". &lt;count&gt; Number of samples to take before terminating. -J&lt;flag&gt; Pass &lt;flag&gt; directly to the runtime system. 参数说明: Option: gc操作相关 vmid: 当前运行的java pid interval: 间隔时间，单位为秒或者毫秒 count* 打印次数，如果缺省则打印无数次 示例： 1jstat -gc 8028 100 10 gc相关说明: S0C：第一个幸存区的大小 S1C：第二个幸存区的大小 S0U：第一个幸存区的使用大小 S1U：第二个幸存区的使用大小 EC：伊甸园区的大小 EU：伊甸园区的使用大小 OC：老年代大小 OU：老年代使用大小 MC：方法区大小 MU：方法区使用大小 CCSC: 压缩类空间大小 CCSU: 压缩类空间使用大小 YGC: 年轻代垃圾回收次数 YGCT: 年轻代垃圾回收消耗时间 FGC: 老年代垃圾回收次数 FGCT: 老年代垃圾回收消耗时间 GCT: 垃圾回收消耗总时间 Options参数: 12345678910111213jstat -options -h-class-compiler-gc-gccapacity-gccause-gcmetacapacity-gcnew-gcnewcapacity-gcold-gcoldcapacity-gcutil-printcompilation options参数说明: jstat -class pid: 显示加载class的数量，及所占空间等信息 jstat -compiler pid: VM实时编译的数量等信息 jstat -gc pid: 显示gc的信息，查看gc的次数，及时间 jstat -gccapacity pid: 堆内存中对象的使用和占用大小 jstat -gccause pid: jstat -gcnew pid: 年轻代对象的信息 jstat -gcnewcapacity pid: 年轻代对象的信息及其占用量 jstat -gcold pid: 老年代对象的信息 jstat -gcoldcapacity pid: 老年代对象的信息及其占用量 jstat -gcutil pid: gc信息汇总 jstat -printcompilation pid: 当前VM执行的信息 jstat -gcmetacapacity pid: 元数据空间统计 5. jinfo用来查看正在运行的 java 应用程序的扩展参数，包括Java System属性和JVM命令行参数；也可以动态的修改正在运行的 JVM 一些参数。 1234567891011121314151617jinfo -hUsage: jinfo [option] &lt;pid&gt; (to connect to running process) jinfo [option] &lt;executable &lt;core&gt; (to connect to a core file) jinfo [option] [server_id@]&lt;remote server IP or hostname&gt; (to connect to remote debug server)where &lt;option&gt; is one of: -flag &lt;name&gt; to print the value of the named VM flag -flag [+|-]&lt;name&gt; to enable or disable the named VM flag -flag &lt;name&gt;=&lt;value&gt; to set the named VM flag to the given value -flags to print VM flags -sysprops to print Java system properties &lt;no option&gt; to print both of the above -h | -help to print this help message 参数说明: jinfo: 输出全部的参数和系统属性 jinfo -flag name: 输出对应名称的参数 jinfo -flag [+|-]name: 开启或者关闭对应名称的参数 jinfo -flag name=value: 设定对应名称的参数 jinfo -flags: 输出全部的参数 jinfo -sysprops: 输出系统属性","categories":[{"name":"gc","slug":"gc","permalink":"http://www.xxzp.tech/categories/gc/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.xxzp.tech/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.xxzp.tech/tags/jvm/"},{"name":"gc","slug":"gc","permalink":"http://www.xxzp.tech/tags/gc/"}]},{"title":"redis 分布式锁实现","slug":"redis 分布式锁实现","date":"2018-09-04T16:00:00.000Z","updated":"2018-09-05T15:25:54.000Z","comments":true,"path":"2018/09/05/redis 分布式锁实现/","link":"","permalink":"http://www.xxzp.tech/2018/09/05/redis 分布式锁实现/","excerpt":"1. 概述我们对于 redis 设计的原则是，在设计 key 时必须设置过期时间，因此在用 setnx 和 expire 时是两个操作，不符合锁的原子性操作，所以我们在设计分布式锁的时候必须把两个命令一起提交给 redis 服务端，而不是在客户端操作。基于 redis 是单线程运行，而 lua 脚本执行过程是顺序执行的，所以我们可以考虑结合 lua 脚本提交，保证客户端的操作是原子的，而 redis 服务端可以保证提交的操作是原子性和顺序性。","text":"1. 概述我们对于 redis 设计的原则是，在设计 key 时必须设置过期时间，因此在用 setnx 和 expire 时是两个操作，不符合锁的原子性操作，所以我们在设计分布式锁的时候必须把两个命令一起提交给 redis 服务端，而不是在客户端操作。基于 redis 是单线程运行，而 lua 脚本执行过程是顺序执行的，所以我们可以考虑结合 lua 脚本提交，保证客户端的操作是原子的，而 redis 服务端可以保证提交的操作是原子性和顺序性。 2. redis 分布式锁实现2.1 spring-boot 配置此篇是基于 spring-data-redis 实现，在进行分布式实现之前先实现与 spring-boot 集成。 引入依赖： 123compile('org.springframework.boot:spring-boot-starter-data-redis')compile('org.apache.commons:commons-pool2')compile('org.apache.commons:commons-lang3') 上面引入 commons-pools2 为了使用 luttce 连接池，commons-lang3 为了使用一些工具包。 配置：在 application.yml 文件中配置： 12345678910spring: redis: host: localhost port: 6379 lettuce: pool: max-idle: 8 max-active: 8 max-wait: -1 timeout: 1000 Redis配置类：这里定义一个 Bean 在项目加载时初始化。 123456789101112@Configuration@EnableCaching@ConditionalOnClass(RedisOperations.class)@EnableConfigurationProperties(RedisProperties.class)public class RedisConfig extends CachingConfigurerSupport &#123; @Bean @ConditionalOnMissingBean(name = \"stringRedisTemplate\") public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory factory) &#123; return new StringRedisTemplate(); &#125;&#125; 到这基本上完成了基本配置，上面的配置没有使用自定义序列化与反序列化。 2.2 基于 redis 分布式锁实现实现是基于接口的方式，思路来源于 juc 包中 Lock 的实现方式。 接口定义如下： 1234567891011121314151617181920212223public interface DistributeLock &#123; int TIMEOUT_SECONDS = 60; int RETRY_TIMES = 2; int SLEEP_MILLIS = 500; boolean tryLockTime(String key, String value)throws Exception; boolean tryLockTimes(String key, String value, int retryTimes) throws Exception; boolean tryLockTimes(String key, String value, int expire, int retryTimes) throws Exception; boolean tryLockTimes(String key, String value, int expire, int retryTimes, int sleepMills) throws Exception; boolean lock(String key, String value, int expire); boolean lock(String key, String value); boolean releaseLock(String key, String value);&#125; 上面接口中 try 开头的是可以重试，lock 不带重试，实现都带过期时间,reentrantLock 为可重入锁。 抽象类： 1234567891011121314151617181920212223public abstract class AbstractDistributeLock implements DistributeLock &#123; @Override public boolean tryLockTime(String key, String value) throws Exception &#123; return false; &#125; @Override public boolean tryLockTimes(String key, String value, int retryTimes)throws Exception &#123; return tryLockTimes(key, value, TIMEOUT_SECONDS, retryTimes, SLEEP_MILLIS); &#125; @Override public boolean tryLockTimes(String key, String value, int expire, int retryTimes)throws Exception &#123; return tryLockTimes(key, value, expire, retryTimes, SLEEP_MILLIS); &#125; @Override public boolean lock(String key, String value) &#123; return lock(key, value, TIMEOUT_SECONDS); &#125;&#125; 实现类如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879@Servicepublic class RedisDistributedLock extends AbstractDistributeLock &#123; @Resource private StringRedisTemplate stringRedisTemplate; private static final RedisScript&lt;Boolean&gt; LOCK_SCRIPT; static &#123; StringBuilder sb = new StringBuilder(); sb.append(\"if (redis.call('setnx', KEYS[1], ARGV[1]) == 1) then\\n\"); sb.append(\"\\t\\tredis.call('expire', KEYS[1], tonumber(ARGV[2]))\\n\"); sb.append(\"\\t\\treturn true\\n\"); sb.append(\"end\\n\"); sb.append(\"return false\"); LOCK_SCRIPT = new DefaultRedisScript&lt;&gt;(sb.toString(), Boolean.class); &#125; private static final RedisScript&lt;Boolean&gt; UN_LOCK_SCRIPT; static &#123; StringBuilder sb = new StringBuilder(); sb.append(\"if (redis.call('get', KEYS[1]) == ARGV[1]) then\\n\"); sb.append(\"\\t\\tredis.call('del', KEYS[1])\\n\"); sb.append(\"\\t\\treturn true\\n\"); sb.append(\"end\\n\"); sb.append(\"\\t\\treturn false\\n\"); UN_LOCK_SCRIPT = new DefaultRedisScript&lt;&gt;(sb.toString(), Boolean.class); &#125; @Override public boolean lock(String key, String value, int expire) &#123; return StringUtils.isNotBlank(key) &amp;&amp; StringUtils.isNotBlank(value) &amp;&amp; doLock(key, value, expire); //return StringUtils.isNotBlank(key) &amp;&amp; StringUtils.isNotBlank(value) &amp;&amp; doLock1(key, value, //expire); &#125; @Override public boolean tryLockTimes(String key, String value, int expire, int retryTimes, int sleepMills) throws Exception &#123; boolean lock = doLock(key, value, expire); while (retryTimes &lt;= 0) &#123; TimeUnit.SECONDS.sleep(sleepMills); lock = doLock(key, value, expire); retryTimes--; &#125; return lock; &#125; private boolean doLock(String key, String value, int expire) &#123; Object object = stringRedisTemplate .execute(LOCK_SCRIPT, Collections.singletonList(key), value, String.valueOf(expire)); if (Objects.isNull(object)) &#123; return false; &#125; return (Boolean) object; &#125; private Boolean doLock1(String key, String value, int expire) &#123; return stringRedisTemplate.execute((RedisCallback&lt;Boolean&gt;) connection -&gt; &#123; RedisStringCommands commands = connection.stringCommands(); Boolean lock = commands.set(key.getBytes(), value.getBytes(), Expiration.seconds(expire), SetOption.SET_IF_ABSENT); return !Objects.isNull(lock); &#125;); &#125; @Override public boolean releaseLock(String key, String value) &#123; Object object = stringRedisTemplate .execute(UN_LOCK_SCRIPT, Collections.singletonList(key), value); if (Objects.isNull(object)) &#123; return true; &#125; return (Boolean) object; &#125;&#125; 上面实现了 doLock() 与 doLock1()，doLock() 通过 lua 脚本提交命令，具体操作交由 redis 服务端。doLock1() 是基于 StringRedisTemplate 实现，最终是通过 lettuce 实现。 测试如下： 123456789101112@Resourceprivate DistributeLock lock;@GetMapping(\"/redis/lock\")public Boolean getLock() &#123; String uuid = UUID.randomUUID().toString(); return lock.lock(\"test_lock\", uuid);&#125;@GetMapping(\"/redis/releaseLock\")public Boolean releaseLock(String key, String value) &#123; return lock.releaseLock(key, value);&#125; 可重入锁： 通过 ThreadLocal 实现计数 12345678910111213141516171819202122232425262728293031323334353637383940public boolean reentrantLock(String key, String value) &#123; ConcurrentHashMap&lt;String, Integer&gt; map = currentLock(); Integer cnt = map.get(key); if (Objects.nonNull(cnt)) &#123; cnt = cnt + 1; map.put(key, cnt); return true; &#125; boolean lock = doLock(key, value, TIMEOUT_SECONDS); if (lock) &#123; map.put(key, 1); return true; &#125; return false;&#125;private ConcurrentHashMap&lt;String, Integer&gt; currentLock() &#123; ConcurrentHashMap&lt;String, Integer&gt; refs = lockers.get(); if (refs != null) &#123; return refs; &#125; lockers.set(new ConcurrentHashMap&lt;&gt;()); return lockers.get();&#125;public boolean unReentrantLock(String key, String value) &#123; ConcurrentHashMap&lt;String, Integer&gt; map = currentLock(); Integer refCnt = map.get(key); if (Objects.isNull(refCnt)) &#123; return false; &#125; refCnt = refCnt - 1; if (refCnt &gt; 0) &#123; map.put(key, refCnt); &#125; else &#123; map.remove(key); releaseLock(key, value); &#125; return true;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://www.xxzp.tech/categories/java/"},{"name":"redis","slug":"java/redis","permalink":"http://www.xxzp.tech/categories/java/redis/"},{"name":"spring boot","slug":"java/redis/spring-boot","permalink":"http://www.xxzp.tech/categories/java/redis/spring-boot/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.xxzp.tech/tags/java/"},{"name":"redis","slug":"redis","permalink":"http://www.xxzp.tech/tags/redis/"}]},{"title":"CMS 深入分析","slug":"CMS 深入","date":"2018-09-01T16:00:00.000Z","updated":"2019-05-12T08:56:27.932Z","comments":true,"path":"2018/09/02/CMS 深入/","link":"","permalink":"http://www.xxzp.tech/2018/09/02/CMS 深入/","excerpt":"1. 概述CMS(Concurrent Mark Sweep): 并发收集器，，作用于老年代，通常与ParNew配合使用。CMS收集器工作的整个流程分为以下4个步骤： 初始标记（CMS initial mark）：仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，需要 Stop The World 并发标记（CMS concurrent mark）：进行GC Roots Tracing的过程，在整个过程中耗时最长 重新标记（CMS remark）：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。此阶段也需要 Stop The World 并发清除（CMS concurrent sweep）","text":"1. 概述CMS(Concurrent Mark Sweep): 并发收集器，，作用于老年代，通常与ParNew配合使用。CMS收集器工作的整个流程分为以下4个步骤： 初始标记（CMS initial mark）：仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，需要 Stop The World 并发标记（CMS concurrent mark）：进行GC Roots Tracing的过程，在整个过程中耗时最长 重新标记（CMS remark）：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。此阶段也需要 Stop The World 并发清除（CMS concurrent sweep） 从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的，下图为 CMS 与应用线程关系如下图： 优点： 并发收集、低停顿 缺点： 对CPU资源非常敏感：CMS默认启动的回收线程数是（CPU数量+3）/4，也就是当CPU在4个以上时，并发回收时垃圾收集线程不少于25%的CPU资源，并且随着CPU数量的增加而下降。但是当CPU不足4个时（比如2个），CMS对用户程序的影响就可能变得很大，如果本来CPU负载就比较大，还要分出一半的运算能力去执行收集器线程。 无法处理浮动垃圾：由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生。这一部分垃圾出现在标记过程之后，CMS无法再当次收集中处理掉它们，只好留待下一次GC时再清理掉。 标记-清除算法导致的空间碎片：CMS是一款基于“标记-清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象。 2. cms 实践下图为 cms gc log: 从上图可看到，日志包含 gc 相关参数与 gc 动作与内存信息，下面将进行详细分析。 2.1 cms 日志解析先看这一段： 12345670.627: [Full GC (Allocation Failure) 0.627: [CMS: 215379K-&gt;215367K(327680K), 0.0206276 secs] 215379K-&gt;215367K(504640K), [Metaspace: 2694K-&gt;2694K(1056768K)], 0.0207120 secs] [Times: user=0.02 sys=0.00, real=0.02 secs]0.649: [GC (CMS Initial Mark) [1 CMS-initial-mark: 215367K(327680K)] 215367K(504640K), 0.0001627 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]0.649: [CMS-concurrent-mark-start]0.889: [CMS-concurrent-mark: 0.002/0.240 secs] [Times: user=0.01 sys=0.11, real=0.24 secs]0.889: [CMS-concurrent-preclean-start]0.890: [CMS-concurrent-preclean: 0.001/0.001 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]0.890: [CMS-concurrent-abortable-preclean-start] 上面的日志对应 cms 的四个过程（概述中说明）。包含具体的空间信息和执行时间 10.227: [GC (Allocation Failure) 0.228: [ParNew: 111838K-&gt;10608K(176960K), 0.0749171 secs] 111838K-&gt;102770K(504640K), 0.0750134 secs] [Times: user=0.24 sys=0.04, real=0.07 secs] GC：用来区分(distinguish)是 Minor GC 还是 Full GC 的标志(Flag). 这里的 GC 表明本次发生的是 Minor GC Allocation Failure：引起垃圾回收的原因，本次GC是因为年轻代中没有任何合适的区域能够存放需要分配的数据结构而触发的 ParNew：使用的垃圾收集器的名字，多线程收集器，新生代采用复制算法，老年代采用标记-整理，会产生 stop-the-world 111838K-&gt;10608K(176960K), 0.0749171 secs] 111838K-&gt;102770K(504640K)：堆内存变化情况 0.0750134 secs：gc时间 [Times: user=0.24 sys=0.04, real=0.07 secs]： user – 此次垃圾回收, 垃圾收集线程消耗的所有CPU时间(Total CPU time) sys – 操作系统调用(OS call) 以及等待系统事件的时间(waiting for system event) real – 应用程序暂停的时间(Clock time) 2.2 cms 常用参数首先看下上面示例中的参数配置，这些参数包含 gc 日志相关和堆相关： 1-XX:CMSInitiatingOccupancyFraction=85 -XX:CMSMaxAbortablePrecleanTime=5000 -XX:+DisableExplicitGC -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/data/logs/gc/HeapDumpOnOutOfMemoryError.log -XX:InitialHeapSize=536870912 -XX:MaxHeapSize=536870912 -XX:MaxNewSize=201326592 -XX:MaxTenuringThreshold=6 -XX:NewSize=201326592 -XX:OldPLABSize=16 -XX:ParallelGCThreads=4 -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:ThreadStackSize=256 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseConcMarkSweepGC -XX:+UseParNewGC 老年代 gc 采用的是 CMS，新生代 gc 为 ParNew。下面为 CMS 一些相关参数说明：CMS initiating options： -XX:+UseCMSInitiatingOccupancyOnly：仅使用预定义的占用率作为启动CMS集合的唯一标准，禁止 JVM 自适应行为 -XX:CMSInitiatingOccupancyFraction=70：设置CMS收集开始的百分比。默认值是-1，负值表示使用 -XX:CMSTriggerRatio 选项来定义这个百分比数 -XX:CMSBootstrapOccupancy=50 -XX:CMSTriggerRatio=70：设置由-XX:MinHeapFreeRatio指定值的百分比的值 -XX:CMSTriggerInterval=60000：gc 触发周期，默认为 -1 表示不执行 CMS Stop-the-World pauses tuning： -XX:CMSWaitDuration=30000：CMSThread默认2秒钟扫描一次，判断是否需要CMS，这个参数可以更改这个扫描时间间隔 -XX:+CMSScavengeBeforeRemark：CMS GC会以新生代作为GC Root的一部分, \b强制新生代在 remark 之前做一次YGC, 能够一定程度上减少GC Root扫描的开销, 从而减少CMS remark时间 -XX:+CMSScheduleRemarkEdenSizeThreshold：预清理阶段发生的前提是，新生代Eden区的内存使用量大于参数CMSScheduleRemarkEdenSizeThreshold 默认是2M，如果新生代的对象太少，就没有必要执行预清理阶段，直接执行重新标记阶段 -XX:CMSScheduleRemarkEdenPenetration=20：如果Eden区的内存使用率达到了阈值CMSScheduleRemarkEdenPenetration指定的百分比，默认50%，会退出预清理循环 -XX:CMSScheduleRemarkSamplingRatio=4 新生代达到预计的比例时开始标记 CMS Concurrency options： -XX:+CMSParallelInitialMarkEnabled：JDK8默认为true，其含义是CMS GC初始化标记阶段并行执行 -XX:+CMSParallelRemarkEnabled：GC重新标记阶段并行执行，JDK7&amp;JDK8中默认值都是true -XX:+CMSParallelSurvivorRemarkEnabled：新生代并发标记，默认值为true -XX:+CMSConcurrentMTEnabled：使用多线程标记","categories":[{"name":"gc","slug":"gc","permalink":"http://www.xxzp.tech/categories/gc/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"http://www.xxzp.tech/tags/jvm/"},{"name":"gc","slug":"gc","permalink":"http://www.xxzp.tech/tags/gc/"}]},{"title":"分代 GC 分析","slug":"分代GC算法分析","date":"2018-09-01T16:00:00.000Z","updated":"2018-09-02T13:44:03.000Z","comments":true,"path":"2018/09/02/分代GC算法分析/","link":"","permalink":"http://www.xxzp.tech/2018/09/02/分代GC算法分析/","excerpt":"1. 概述分代回收的基本思路，大部分对象都会在短时间内成为垃圾，而经过一定时间依然存活的对象往往存活时间较长。Java程序运行的过程中，会产生大量的对象，其中一些全局对象和连接池相关的对象生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的局部变量而且占大部分，这些对象生命周期会比较短。针对这样的特性，对于生命周期比较短的对象存放在特定的内存区域，重点扫描回收这样可以更有效的回收非活对象。","text":"1. 概述分代回收的基本思路，大部分对象都会在短时间内成为垃圾，而经过一定时间依然存活的对象往往存活时间较长。Java程序运行的过程中，会产生大量的对象，其中一些全局对象和连接池相关的对象生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的局部变量而且占大部分，这些对象生命周期会比较短。针对这样的特性，对于生命周期比较短的对象存放在特定的内存区域，重点扫描回收这样可以更有效的回收非活对象。 分代回收策略中，对象按照生成时间进行分代，刚刚生成不久的年轻对象划为新生代（Young gen-eration），而存活了较长时间的对象划为老生代（Old generation）。采用分代回收策略，可以对新生代和老年代采用不同的回收算法，在新生代，对象“朝生夕死”。gc一般采取复制算法，因为此算法的突出特点就是只关心哪些需要被复制，可达性分析只用标记和复制很少的存活对象，而根据老年代对象的特点，一般采用标记-清理策略的算法。采用分代策略，gc时进行可达性分析的范围能大大降低，在分代回收中，新生代的规模比老年代小，回收频率也要高，显然新生代gc的时候不能去遍历老年代。 2. jvm 分代策略jvm 中分代策略如下图； 2.1 新生代新生代有划分为Eden、From Survivor和To Survivor三个部分，他们对应的内存空间的大小比例为 8:1:1，为对象分配内存的时候，首先使用Eden空间，经过GC后，没有被回收的会首先进入 From 区域，任何时候，都会保持一个 Survivorq 区域（From 或 To）完全空闲，也就是说新生代的内存利用率最大为90%。 From 和To 两个区域会根据GC的实际情况，进行互换，将 From 区域中的对象全部复制到 To区域中，或者反过来，将 To 区域中的对象全部复制到 From 区域中。一般 new 一个对象时，它会在 Eden 区中划出一块作为存储对象的内存，由于堆空间是线程共享的，因此直接在这里边划空间是需要进行同步的。 2.2 老年代对象经过多次GC以后，经过Eden Space，多次经过 From 和 To 之后进入年老代，而且对象在年老代的存活时间比较长，如果进行使用复制算法来进行GC，需要移动大量的对象，导致效率很低。所以，年老代适合使用标记-清除算法，需要被GC的对象很少，那么标记的对象就很少，在对标记的对象进行回收，效率就会很高。 3. 内存分配过程 对象优先在Eden分配 大对象直接进入老年代 长期存活的对象将进入老年代：对象在Eden出生并经过第一次的Minor GC后仍然存活，并且能被Surivivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Surivivor区中每熬过一次MinorGC，年龄就增加一岁，当它的年龄增加到一定程度（默认15岁），就会被晋升到老年代中。 动态对象年龄判定：如果Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于改年龄的对象就可以直接进入老年代，无需等到最大年龄阀值。 空间分配担保：在发生Minor GC之前，虚拟机会先检查老年大最大可用连续空间是否大于新生代所有对象总空间，如果条件成立，那么Minor GC是安全的。如果不成立，则虚拟机会检查HandlePrimotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，则尝试一次Minor GC，尽管这次Minor GC是有风险的。如果小于，或者HandlePrimotionFailure设置不允许冒险，那么这时也要改为进行一次Full GC。 4. gc 收集器与策略4.1 垃圾收集器Serial收集器：单线程收集器，新生代采用复制算法，老年代采用标记-整理，会暂停所有用户线程 ParNew收集器：多线程收集器，新生代采用复制算法，老年代采用标记-整理，会暂停所有用户线程。可以与CMS收集器配合工作 Serial Old 收集器：Serial收集器的老年代版本，单线程收集器，采用的是“标记–整理”算法 Parallel Old 收集器：Parallel收集器的老年代版本，多线程收集器，采用的是“标记–整理”算法。在注重吞吐量以及CPU资源敏感的场合，可以考虑Parallel Scavenge和 Parallel Old 组合。 CMS 收集器：并发收集器，低停顿。经过4个步骤：①初始标记②并发标记③重新标记④并发清除。采用“标记–清除算法”。不足：会产生大量空间碎片。①、③仍然需要stop the World G1收集器：G1将堆拆成一系列的分区，这样在一个时间段内，大部分的垃圾收集操作就只是在一个分区内执行，而不是整个堆或整个（老年）代。 4.2 gc 策略默认策略：JVM针对上述不同的分代区域，默认使用的 GC 策略如下： 运行模式 新生代垃GC策略 年老代GC策略 Client Serial GC Serial Old GC Server Parallel Scavenge GC Serial Old GC 平时我们运行Java程序，没有指定任何选项的时候，默认根据上面的GC策略搭配进行GC。 gc 策略组合：JVM调优的过程中，并非任何一种新生代GC策略都可以和另一种年老代GC策略进行配合工作，如下是常用使用组合： 策略 新生代 年老代 说明 1 Serial Serial Old Serial和Serial Old都是单线程进行GC，特点就是GC时暂停所有应用线程 2 Serial CMS+Serial Old CMS是并发GC，实现GC线程和应用线程并发工作，不需要暂停所有应用线程, 当CMS进行GC失败时，会自动使用Serial Old策略进行GC 3 ParNew CMS 使用-XX:+UseParNewGC选项来开启，ParNew是Serial的并行版本，可以指定GC线程数，默认GC线程数为CPU的数量，可以使用-XX:ParallelGCThreads选项指定GC的线程数，如果指定了选项-XX:+UseConcMarkSweepGC选项，则新生代默认使用ParNew GC策略 4 ParNew Serial Old 使用-XX:+UseParNewGC选项来开启。新生代使用ParNew GC策略，年老代默认使用Serial Old GC策略 5 Parallel Scavenge Serial Old Parallel Scavenge策略主要是关注一个可控的吞吐量：应用程序运行时间 / (应用程序运行时间 + GC时间)，适用于后台持久运行的应用程序，而不适用于交互较多的应用程序 6 Parallel Scavenge Parallel Old Parallel Old是Serial Old的并行版本","categories":[{"name":"gc","slug":"gc","permalink":"http://www.xxzp.tech/categories/gc/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"http://www.xxzp.tech/tags/jvm/"},{"name":"gc","slug":"gc","permalink":"http://www.xxzp.tech/tags/gc/"}]},{"title":"GC 初步","slug":"GC 算法概述","date":"2018-08-31T16:00:00.000Z","updated":"2018-09-01T15:09:56.000Z","comments":true,"path":"2018/09/01/GC 算法概述/","link":"","permalink":"http://www.xxzp.tech/2018/09/01/GC 算法概述/","excerpt":"1. 概述1.1 基本概念GC（Garbage Collection ）：垃圾回收。现代语言都把内存回收交给底层去处理，使得程序员在开发过程中不必过多的去关注 gc，然而在遇到各种内存溢出、内存泄漏问题时，当垃圾收集称为系统达到更高并发量的瓶颈时，只有深入理解 gc 和内存分配，才能对这些“自动化”的技术实施必要的监控和调节。 在深入之前我们先看几个基础概念：","text":"1. 概述1.1 基本概念GC（Garbage Collection ）：垃圾回收。现代语言都把内存回收交给底层去处理，使得程序员在开发过程中不必过多的去关注 gc，然而在遇到各种内存溢出、内存泄漏问题时，当垃圾收集称为系统达到更高并发量的瓶颈时，只有深入理解 gc 和内存分配，才能对这些“自动化”的技术实施必要的监控和调节。 在深入之前我们先看几个基础概念： 对象： 在前面深入分析了 java对象 ，其中对象包含了 gc 信息 指针： 大部分语言默认指针是指向对象的首地址，这样不仅指针在语言的应用变得简单，而且使 gc 过程也变得简单 堆： 对象存放内存空间，对于很多语言垃圾回收主要针对堆内存进行回收，这主要是因为 gc 过程是针对对象来处理的 根Root： 对象被引用的起始点 1.2 gc 指标吞吐量： 吞吐量(throughput)指在单位时间内的处理能力，不同的垃圾回收算法在实现上有所不同，如算得算法在活对象较少时吞吐量较好，国为复制算法仅检查活的对象。而标记清除算法会检查所有活对象和非活对象，在对象增多时有可能出现标记清除算法吞吐量比复制算法好 停顿时间： 垃圾回收器运行时，应用程序的暂停时间，垃圾回收时会出现 stop-world，这对系统影响较大，如果停顿时间较长对一些系统是不允许的 垃圾回收频率：垃圾回收器多长时间运行一次。一般而言，频率越低越好，通常增大堆空间可以有效降低垃圾回收发生的频率，但是会增加回收时产生的停顿时间 垃圾回收器负载：垃圾回收器负载=GC耗时/系统总运行时间 2. 对象存活判定2.1 引用计数 引用计数：给对象添加一个引用计数器，每被引用一次计数器值 1，当引用释放则减 1，当值为 0 时就说明已经没有地方引用变为无用对象，可以进行回收。引用计数的增减，一般发生在变量赋值、对象内容更新、函数结束等时间点。当一个对象的引用计数变为0时，则说明它将来不会再被引用，因此可以释放相应的内存空间。引用计数中的对象如图: 循环引用问题：（a-&gt;b-&gt;c-&gt;a）在abc三个对象没有其他引用时，他们三者相互引用，此时已经是无用对象，但是并不能被回收。 jvm源码： 1volatile short _refcount, // needs atomic operation 计数实现(通过cas去实现)： 123456789101112131415161718void Symbol::increment_refcount() &#123; if (_refcount &gt;= 0) &#123; Atomic::inc(&amp;_refcount); NOT_PRODUCT(Atomic::inc(&amp;_total_count);) &#125;&#125;void Symbol::decrement_refcount() &#123; if (_refcount &gt;= 0) &#123; Atomic::dec(&amp;_refcount);#ifdef ASSERT if (_refcount &lt; 0) &#123; print(); assert(false, \"reference count underflow for symbol\"); &#125;#endif &#125;&#125; 2.2 可达性分析可达性分析： 通过一系列的称为“GC Roots”的对象作为起点，从这些节点向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是GC Roots 到这个对象不可达）时，则证明此对象时不可用的。 GC Roots其通常是一组特别管理的指向引用类型对象的指针，这些指针是tracing GC的trace的起点。它们不是对象图里的对象，对象也不可能引用到这些“外部”的指针，这也是tracing GC算法不会出现循环引用问题的基本保证。因此也容易得出，只有引用类型的变量才被认为是Roots，值类型的变量永远不被认为是Roots。只有深刻理解引用类型和值类型的内存分配和管理的不同，才能知道为什么root只能是引用类型。 java GC Roots 对象： 虚拟机栈（栈帧中的局部变量表，Local Variable Table）中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI（即一般说的Native方法）引用的对象 3. 基本回收算法标记-清除：分成“标记”、“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。 空间问题：标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不触发另一次垃圾收集动作。效率问题：因为内存碎片的存在，操作会变得更加费时，因为查找下一个可用空闲块已不再是一个简单操作。 标记－整理：此算法的标记过程与标记－清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。 复制算法：它将可用内存按容量分成大小相等的两块，每次只使用其中的一块。当这一块内存用完，就将还存活着的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。 复制收集方式中，只存在相当于标记清除方式中的标记阶段。由于清除阶段中需要对现存的所有对象进行扫描，在存在大量对象，且其中大部分都即将死亡的情况下，全部扫描一遍的开销实在是不小。而在复制收集方式中，就不存在这样的开销。","categories":[{"name":"gc","slug":"gc","permalink":"http://www.xxzp.tech/categories/gc/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"http://www.xxzp.tech/tags/jvm/"},{"name":"gc","slug":"gc","permalink":"http://www.xxzp.tech/tags/gc/"}]},{"title":"AQS 深入分析","slug":"AQS 深入分析","date":"2018-08-29T16:00:00.000Z","updated":"2018-09-02T01:44:18.000Z","comments":true,"path":"2018/08/30/AQS 深入分析/","link":"","permalink":"http://www.xxzp.tech/2018/08/30/AQS 深入分析/","excerpt":"1. 概述AQS：AbstractQueuedSynchronizer，即队列同步器，是构建锁或者其他同步组件的基础框架，JUC并发包的实现基础。下图都是基于 aqs 实现的，Semaphore，ReentrantLock，ReentrantReadWriteLock，Worker 等。 AQS主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态。在内部使用（volatile int） state来表示同步状态，当state&gt;0时表示已经获取了锁，当state = 0时表示释放了锁。同时提供了getState()、setState(int newState)、compareAndSetState(int expect,int update）来对同步状态state进行操作。通过 FIFO 同步队列来完成线程的排队，如果当前线程获取同步状态失败（锁）时，AQS则会将当前线程以及等待状态等信息构造成一个节点（Node）并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，则会把节点中的线程唤醒，使其再次尝试获取同步状态。","text":"1. 概述AQS：AbstractQueuedSynchronizer，即队列同步器，是构建锁或者其他同步组件的基础框架，JUC并发包的实现基础。下图都是基于 aqs 实现的，Semaphore，ReentrantLock，ReentrantReadWriteLock，Worker 等。 AQS主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态。在内部使用（volatile int） state来表示同步状态，当state&gt;0时表示已经获取了锁，当state = 0时表示释放了锁。同时提供了getState()、setState(int newState)、compareAndSetState(int expect,int update）来对同步状态state进行操作。通过 FIFO 同步队列来完成线程的排队，如果当前线程获取同步状态失败（锁）时，AQS则会将当前线程以及等待状态等信息构造成一个节点（Node）并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，则会把节点中的线程唤醒，使其再次尝试获取同步状态。 2. AQS 数据模型我们先看下 AQS 的成员变量： 12345private transient volatile Node head;private transient volatile Node tail;private volatile int state; 包含了一个队列(Node)的信息和 state (同步状态)，下面是 Node 即 FIFO 队列的结构： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556static final class Node &#123; //共享模式 static final Node SHARED = new Node(); //独占模式 static final Node EXCLUSIVE = null; //值为1，表示当前的线程被取消 static final int CANCELLED = 1; //值为-1，表示当前节点的后继节点包含的线程需要运行 static final int SIGNAL = -1; //值为-2，表示当前节点在等待condition，也就是在condition队列中 static final int CONDITION = -2; //值为-3，表示当前场景下后续的acquireShared能够得以执行,值为0，表示当前节点在sync队列中，等待着获取锁 static final int PROPAGATE = -3; volatile int waitStatus; // 前驱结点 volatile Node prev; // 后继结点 volatile Node next; // 当前线程 volatile Thread thread; // 存储condition队列中的后继节点 Node nextWaiter; // 是否为共享模式 final boolean isShared() &#123; return nextWaiter == SHARED; &#125; // 获取前驱结点 final Node predecessor() throws NullPointerException &#123; Node p = prev; if (p == null) throw new NullPointerException(); else return p; &#125; Node() &#123; &#125; Node(Thread thread, Node mode) &#123; this.nextWaiter = mode; this.thread = thread; &#125; Node(Thread thread, int waitStatus) &#123; this.waitStatus = waitStatus; this.thread = thread; &#125;&#125; 从上面看到 Node 中有两个常量: SHARE: 共享模式指的是允许多个线程获取同一个锁而且可能获取成功 EXCLUSIVE: 独占模式指的是一个锁如果被一个线程持有，其他线程必须等待 3. AQS 操作AQS 操作是通过继续来使用的，AbstractQueuedSynchronizer 类提供了队列的基本操作方法，下面将详细分析： state 操作: 通过 CAS 的方式去设置 state 值 123protected final boolean compareAndSetState(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, stateOffset, expect, update);&#125; 获取独占锁： 12345public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; 我看下两个核心方法： addWaiter()： 通过 CAS 的方式加入队列。 1234567891011121314private Node addWaiter(Node mode) &#123; Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure Node pred = tail; if (pred != null) &#123; node.prev = pred; if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; enq(node); return node;&#125; 下面是初始化队列，也是通过 CAS 的方式去初始化： 123456789101112131415private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail; if (t == null) &#123; // Must initialize if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125;&#125; acquireQueued()：从队列中获取节点： 123456789101112131415161718192021final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 4. 总结AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。CLH 队列是一个虚拟的双向队列，AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）来实现锁的分配。 自定义同步应用示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class AresAqs &#123; private static class Sync extends AbstractQueuedSynchronizer &#123; @Override protected boolean tryAcquire(int arg) &#123; return super.tryAcquire(arg); &#125; @Override protected boolean tryRelease(int arg) &#123; return super.tryRelease(arg); &#125; @Override protected int tryAcquireShared(int arg) &#123; return super.tryAcquireShared(arg); &#125; @Override protected boolean tryReleaseShared(int arg) &#123; return super.tryReleaseShared(arg); &#125; @Override protected boolean isHeldExclusively() &#123; return super.isHeldExclusively(); &#125; &#125; private final Sync sync = new Sync(); public void lock() &#123; sync.tryAcquire(1); &#125; public boolean tryLock() &#123; return sync.tryAcquire(1); &#125; public void unLock() &#123; sync.release(1); &#125;&#125; 在上面示例中，通过内部类继承 AbstractQueuedSynchronizer 来实现同步，其实 ReentrantLock, CountDownLatch, Semphore 这些同步类的实现方式与上面示例实现思路基本一致。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://www.xxzp.tech/tags/java/"},{"name":"并发","slug":"并发","permalink":"http://www.xxzp.tech/tags/并发/"}]},{"title":"CAS 深入分析","slug":"CAS 深入分析","date":"2018-08-28T16:00:00.000Z","updated":"2018-09-02T13:39:14.000Z","comments":true,"path":"2018/08/29/CAS 深入分析/","link":"","permalink":"http://www.xxzp.tech/2018/08/29/CAS 深入分析/","excerpt":"1. 概述** CAS：** 指CompareAndSwap或CompareAndSet，即比较并交换。比较的是当前内存中存储的值与预期原值，交换的是新值与内存中的值。这个操作是硬件层面的指令，因此能够保证原子性。Java通过JNI（本地方法调用）来使用这个原子操作。先看一段计数的代码：","text":"1. 概述** CAS：** 指CompareAndSwap或CompareAndSet，即比较并交换。比较的是当前内存中存储的值与预期原值，交换的是新值与内存中的值。这个操作是硬件层面的指令，因此能够保证原子性。Java通过JNI（本地方法调用）来使用这个原子操作。先看一段计数的代码： 1234567891011121314151617181920212223242526272829303132333435public class AtomicTest &#123; private AtomicInteger atomicInteger = new AtomicInteger(0); private int testUnsafe = 0; private static final int POOL_SIZE = Runtime.getRuntime().availableProcessors(); private static final ThreadFactory THREAD_FACTORY = new ThreadFactoryBuilder() .setNameFormat(\"atomic-test-pool\").build(); private static final ExecutorService POOL_EXECUTOR = new ThreadPoolExecutor(POOL_SIZE, POOL_SIZE, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingDeque&lt;&gt;(65535), THREAD_FACTORY); public static void main(String[] args) &#123; AtomicTest atomicTest = new AtomicTest(); for (int i = 0; i &lt; 100; i++) &#123; POOL_EXECUTOR.execute(() -&gt; atomicTest.safeCount()); System.out.println(\"atomic:\" + atomicTest.atomicInteger); POOL_EXECUTOR.execute(() -&gt; atomicTest.unSafeCount()); System.out.println(\"unsafe:\" + atomicTest.testUnsafe); &#125; &#125; private void safeCount() &#123; for (; ; ) &#123; int i = atomicInteger.get(); boolean suc = atomicInteger.compareAndSet(i, ++i); if (suc) &#123; break; &#125; &#125; &#125; private void unSafeCount() &#123; testUnsafe++; &#125;&#125; 上面两个方法，safeCount通过cas处理线程安全，unSafeCount()处理时出现相同的数值。下面深入分析cas的实现原理。 2. CAS 实现Atomic 主要为了实现原子操作，所谓原子操作就是在执行过程中不能被中断，\b而 CAS 实现的基本思路就是循环进行CAS操作直到成功为止，下面以 AtomicInteger 为例进行分析。AtomicInteger 部分核心代码： 1234567891011121314151617181920212223public class AtomicInteger extends Number implements java.io.Serializable &#123; private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; private volatile int value; static &#123; try &#123; valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField(\"value\")); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125; public AtomicInteger(int initialValue) &#123; value = initialValue; &#125; public final boolean compareAndSet(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, valueOffset, expect, update); &#125; public final int getAndIncrement() &#123; return unsafe.getAndAddInt(this, valueOffset, 1); &#125;&#125; 从上面源码可看到，当初始化一个 AtomicInteger 变量时会转换为被 volatile 修饰的 value。而真正的操作是通过 Unsafe 操作 native 方法实现。 1public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5); 对于加操作在 unsafe 包中源码如下： 12345678public final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 = this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5;&#125; 上面代码其核心还是 compareAndSwapInt() 方法。 3. compareAndSwapInt 在 jvm 中实现在 unsafe.cpp 中 compareAndSwapInt 的实现如下： 123456UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) UnsafeWrapper(\"Unsafe_CompareAndSwapInt\"); oop p = JNIHandles::resolve(obj); jint* addr = (jint *) index_oop_from_field_offset_long(p, offset); return (jint)(Atomic::cmpxchg(x, addr, e)) == e;UNSAFE_END 最后通过 Atomic::cmpxchg() 实现操作： 12345678910111213141516171819jbyte Atomic::cmpxchg(jbyte exchange_value, volatile jbyte* dest, jbyte compare_value) &#123; assert(sizeof(jbyte) == 1, \"assumption.\"); uintptr_t dest_addr = (uintptr_t)dest; uintptr_t offset = dest_addr % sizeof(jint); volatile jint* dest_int = (volatile jint*)(dest_addr - offset); jint cur = *dest_int; jbyte* cur_as_bytes = (jbyte*)(&amp;cur); jint new_val = cur; jbyte* new_val_as_bytes = (jbyte*)(&amp;new_val); new_val_as_bytes[offset] = exchange_value; while (cur_as_bytes[offset] == compare_value) &#123; jint res = cmpxchg(new_val, dest_int, cur); if (res == cur) break; cur = res; new_val = cur; new_val_as_bytes[offset] = exchange_value; &#125; return cur_as_bytes[offset];&#125; 最终根据具体的处理器架构转换成汇编指令来实现CAS。当多处理器时需要在前面加上lock指令。这里的cmpxchgl是x86和Intel架构中的compare and exchange指令。在实际执行时，CPU可以通过锁总线或锁缓存: 12345678inline jint Atomic::cmpxchg (jint exchange_value, volatile jint* dest, jint compare_value) &#123; int mp = os::is_MP(); __asm__ volatile (LOCK_IF_MP(%4) &quot;cmpxchgl %1,(%3)&quot; : &quot;=a&quot; (exchange_value) : &quot;r&quot; (exchange_value), &quot;a&quot; (compare_value), &quot;r&quot; (dest), &quot;r&quot; (mp) : &quot;cc&quot;, &quot;memory&quot;); return exchange_value;&#125; 汇编代码说明：volatile：禁止该读写指令重排序LOCK_IF_MP：MP表示多核，如果为多核则为cmpxchg指令添加lock前缀，实现处理器的原子操作 4. ABA问题CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了，这就是 ABA 问题。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一。AtomicStampedReference来解决ABA问题。这个类的 compareAndSet 方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值，其源码如下： 123456789101112131415161718192021222324252627282930public class AtomicStampedReference&lt;V&gt; &#123; private static class Pair&lt;T&gt; &#123; final T reference; final int stamp; private Pair(T reference, int stamp) &#123; this.reference = reference; this.stamp = stamp; &#125; static &lt;T&gt; Pair&lt;T&gt; of(T reference, int stamp) &#123; return new Pair&lt;T&gt;(reference, stamp); &#125; &#125; ....... public boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp) &#123; Pair&lt;V&gt; current = pair; return expectedReference == current.reference &amp;&amp; expectedStamp == current.stamp &amp;&amp; ((newReference == current.reference &amp;&amp; newStamp == current.stamp) || casPair(current, Pair.of(newReference, newStamp))); &#125; private boolean casPair(Pair&lt;V&gt; cmp, Pair&lt;V&gt; val) &#123; return UNSAFE.compareAndSwapObject(this, pairOffset, cmp, val); &#125;&#125; ** 总结 **cas 是 concurrent 包的基础，concurrent包中的源代码实现，会发现一个通用化的实现模式：通过 olatile 声明共享变量，使用 CAS 的原子条件更新来实现线程之间的同步，最终通过 volatile 与 CAS 读/写内存原子语义来实现线程之间的通信。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://www.xxzp.tech/tags/java/"},{"name":"并发","slug":"并发","permalink":"http://www.xxzp.tech/tags/并发/"}]},{"title":"synchronized 实现机制分析","slug":" synchronized 实现机制分析","date":"2018-08-27T16:00:00.000Z","updated":"2018-08-28T16:06:46.000Z","comments":true,"path":"2018/08/28/ synchronized 实现机制分析/","link":"","permalink":"http://www.xxzp.tech/2018/08/28/ synchronized 实现机制分析/","excerpt":"1. 概述synchronized 关键字用来对程序进行加锁，它既可以用来声明一个 synchronized 代码块，也可以直接标记静态方法或者实例方法，\b被 synchronized 可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。先通过一段代码看下 jvm 层面的控制：","text":"1. 概述synchronized 关键字用来对程序进行加锁，它既可以用来声明一个 synchronized 代码块，也可以直接标记静态方法或者实例方法，\b被 synchronized 可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。先通过一段代码看下 jvm 层面的控制： 12345678910111213public class SynchronizedTest &#123; private synchronized void test(Object o) &#123; o.hashCode(); &#125; private void test1(Object o) &#123; synchronized (o) &#123; o.hashCode(); &#125; &#125;&#125; 下面是反汇编的结果： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public desinpattern.singleton.SynchronizedTest();descriptor: ()Vflags: ACC_PUBLICCode: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 3: 0private synchronized void test(java.lang.Object);descriptor: (Ljava/lang/Object;)Vflags: ACC_PRIVATE, ACC_SYNCHRONIZEDCode: stack=1, locals=2, args_size=2 0: aload_1 1: invokevirtual #2 // Method java/lang/Object.hashCode:()I 4: pop 5: return LineNumberTable: line 6: 0 line 7: 5private void test1(java.lang.Object);descriptor: (Ljava/lang/Object;)Vflags: ACC_PRIVATECode: stack=2, locals=4, args_size=2 0: aload_1 1: dup 2: astore_2 3: monitorenter 4: aload_1 5: invokevirtual #2 // Method java/lang/Object.hashCode:()I 8: pop 9: aload_2 10: monitorexit 11: goto 19 14: astore_3 15: aload_2 16: monitorexit 17: aload_3 18: athrow 19: return Exception table: from to target type 4 11 14 any 14 17 14 any LineNumberTable: line 10: 0 line 11: 4 line 12: 9 line 13: 19 StackMapTable: number_of_entries = 2 frame_type = 255 /* full_frame */ offset_delta = 14 locals = [ class desinpattern/singleton/SynchronizedTest, class java/lang/Object, class java/lang/Object ] stack = [ class java/lang/Throwable ] frame_type = 250 /* chop */ offset_delta = 4 在 synchronized 修饰代码块的时候，上面的字节码中包含一个 monitorenter 指令以及多个 monitorexit 指令，\b因为 Java 虚拟机需要确保所获得的锁在正常执行路径，以及异常执行路径上都能够被解锁。在修饰方法时，字节码中方法的访问标记包括 ACC_SYNCHRONIZED。该标记表示在进入该方法时，Java 虚拟机需要进行 monitorenter 操作。而在退出该方法时，不管是正常返回，还是向调用者抛异常，Java 虚拟机均需要进行 monitorexit 操作。这里 monitorenter 和 monitorexit 操作所对应的锁对象是隐式的。 2. 实现原理分析（monitor）synchronized 在Java虚拟机中由monitor entry 和 exit实现，或者显式地通过使用monitorenter和monitorexit指令(by use of the monitorenter and monitorexit instructions)或者隐式地通过方法调用和返回指令（by the method invocation and return instructions）实现，而 monitor 与对象密切相关 (java 对象分析)。 我们先看下 Monitor 的构造函数(Monitor.cpp)： 123456789101112131415161718192021222324Monitor::Monitor(jvmtiEnv *jvmti, JNIEnv *env, jobject object)&#123; jvmtiError err; jclass klass; char *signature; /* Clear counters */ contends = 0; waits = 0; timeouts = 0; /* Get the class name for this monitor object */ (void)strcpy(name, \"Unknown\"); klass = env-&gt;GetObjectClass(object); if ( klass == NULL ) &#123; fatal_error(\"ERROR: Cannot find jclass from jobject\\n\"); &#125; err = jvmti-&gt;GetClassSignature(klass, &amp;signature, NULL); check_jvmti_error(jvmti, err, \"get class signature\"); if ( signature != NULL ) &#123; (void)strncpy(name, signature, (int)sizeof(name)-1); deallocate(jvmti, signature); &#125;&#125; 从上面可看到每个对象都存在着一个 monitor 与之关联，对象与其 monitor 之间的关系有存在多种实现方式，如monitor可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个 monitor 被某个线程持有后，它便处于锁定状态。在Java虚拟机(HotSpot)中，monitor 是由 ObjectMonitor 实现的，其主要数据结构如下(ObjectMonitor.hpp)： 12345678910111213141516171819ObjectMonitor() &#123; _header = NULL; _count = 0; _waiters = 0, _recursions = 0; _object = NULL; _owner = NULL; _WaitSet = NULL; _WaitSetLock = 0 ; _Responsible = NULL ; _succ = NULL ; _cxq = NULL ; FreeNext = NULL ; _EntryList = NULL ; _SpinFreq = 0 ; _SpinClock = 0 ; OwnerIsThread = 0 ; _previous_owner_tid = 0; &#125; ** ObjectMonitor结构简单说明：**_WaitSet与 _EntryList：用来保存ObjectWaiter对象列表，每个等待锁的线程都会被封装成ObjectWaiter对象_owner：指向持有ObjectMonitor对象的线程 ** monitor同步过程：**当多个线程同时访问一段同步代码时，首先会进入 _EntryList 集合，当线程获取到对象的 monitor 后进入 _Owner 区域并把 monitor 中的 owner 变量设置为当前线程同时 monitor 中的计数器 count 加1，若线程调用 wait() 方法，将释放当前持有的 monitor，owner 变量恢复为null，count 自减1，同时该线程进入 WaitSet 集合中等待被唤醒。若当前线程执行完毕也将释放 monitor 并复位变量的值，以便其他线程进入获取 monitor。如下图： 加锁过程核心代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455void ATTR ObjectMonitor::enter(TRAPS) &#123; Thread * const Self = THREAD ; void * cur ; //通过CAS尝试把monitor的`_owner`字段设置为当前线程 cur = Atomic::cmpxchg_ptr (Self, &amp;_owner, NULL) ; ...省略部分代码... // 如果当前线程是第一次进入该monitor，设置_recursions为1，_owner为当前线程 if (cur == Self) &#123; // TODO-FIXME: check for integer overflow! BUGID 6557169. _recursions ++ ; return ; &#125; // 如果当前线程是第一次进入该monitor，设置_recursions为1，_owner为当前线程 if (Self-&gt;is_lock_owned ((address)cur)) &#123; assert (_recursions == 0, \"internal state error\"); _recursions = 1 ; // Commute owner from a thread-specific on-stack BasicLockObject address to // a full-fledged \"Thread *\". _owner = Self ; OwnerIsThread = 1 ; return ; &#125; // 通过cas计数 Atomic::inc_ptr(&amp;_count); // 通过自旋执行ObjectMonitor::EnterI方法等待锁的释放 for (;;) &#123; jt-&gt;set_suspend_equivalent(); // cleared by handle_special_suspend_equivalent_condition() // or java_suspend_self() EnterI (THREAD) ; if (!ExitSuspendEquivalent(jt)) break ; // // We have acquired the contended monitor, but while we were // waiting another thread suspended us. We don't want to enter // the monitor while suspended because that would surprise the // thread that suspended us. // _recursions = 0 ; _succ = NULL ; exit (false, Self) ; jt-&gt;java_suspend_self(); &#125; Self-&gt;set_current_pending_monitor(NULL); &#125;&#125; 从上面可看出，在加锁的过程中大量用到了cas，这也是1.6后对synchronized的优化，其实在锁释放的过程也是通过cas去处理的，具体细节不再描述。 3. 锁优化** 自旋锁：** 让线程等待一段时间（死循环），不会被立即挂起，看持有锁的线程是否会很快释放锁，不会产生上下文切换。** 适应自旋锁：** 对自旋锁的优化，自旋的次数不再是固定的，由上一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。** 锁消除：** JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除。** 锁粗化：** 仅在共享数据的实际作用域中才进行同步，减少锁竞争带来的上下文切换，最常见的如jdk1.7 ConcurrentHashMap 的分段锁。** 锁升级：** 无锁状态 –&gt; 偏向锁状态 –&gt; 轻量级锁状态 –&gt; 重量级锁状态","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://www.xxzp.tech/tags/java/"},{"name":"并发","slug":"并发","permalink":"http://www.xxzp.tech/tags/并发/"}]},{"title":"volatile 实现机制分析","slug":"volatile 实现机制分析","date":"2018-08-27T16:00:00.000Z","updated":"2018-08-28T10:08:37.000Z","comments":true,"path":"2018/08/28/volatile 实现机制分析/","link":"","permalink":"http://www.xxzp.tech/2018/08/28/volatile 实现机制分析/","excerpt":"1. 概述在上篇总结了JMM理论基础，在本篇要分析 volatile 的实现机制。首先看下下面代码： 12345678910111213141516171819public class LazyInitializedSingleton &#123; private static LazyInitializedSingleton instance; private LazyInitializedSingleton() &#123; &#125; public static LazyInitializedSingleton getInstanceUsingDoubleLocking() &#123; if (Objects.isNull(instance )) &#123; synchronized (LazyInitializedSingleton.class) &#123; if (Objects.isNull(instance )) &#123; //可能出现重排序导致线程安全问题 instance = new LazyInitializedSingleton(); &#125; &#125; &#125; return instance; &#125;&#125;","text":"1. 概述在上篇总结了JMM理论基础，在本篇要分析 volatile 的实现机制。首先看下下面代码： 12345678910111213141516171819public class LazyInitializedSingleton &#123; private static LazyInitializedSingleton instance; private LazyInitializedSingleton() &#123; &#125; public static LazyInitializedSingleton getInstanceUsingDoubleLocking() &#123; if (Objects.isNull(instance )) &#123; synchronized (LazyInitializedSingleton.class) &#123; if (Objects.isNull(instance )) &#123; //可能出现重排序导致线程安全问题 instance = new LazyInitializedSingleton(); &#125; &#125; &#125; return instance; &#125;&#125; 上面代码虽然已经加锁和两次判断，但仍可能因为重排序导致线程安全问题，为什么会发生重排序可以看这篇java 对象分析 。下面安全的单例模式实现： 1234567891011121314151617public class DoubleCheckVolatile &#123; private static volatile DoubleCheckVolatile instance; private DoubleCheckVolatile() &#123; &#125; public static DoubleCheckVolatile getInstanceVolatile() &#123; if (Objects.isNull(instance)) &#123; synchronized (LazyInitializedSingleton.class) &#123; if (Objects.isNull(instance)) &#123; instance = new DoubleCheckVolatile(); &#125; &#125; &#125; return instance; &#125;&#125; 上段代码之所以可以保证线程安全是因为volatile禁止指令重排序。那 volatile 是如何保证的呢? 2. volatile 原理分析 volatile是通过 JMM 内存屏障（memory barrier）来禁止重排序 Java 内存模型是通过内存屏障（memory barrier）来禁止重排序的。对于即时编译器来说，它会对每一个 happens-before 关系，向正在编译的目标方法中插入相应的读读、读写、写读以及写写内存屏障。 ** volatile 变量特性: **(可保证一定的有序性，不能保证原子性)： 可见性：对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入。 原子性：对任意单个 volatile 变量的读/写具有原子性，但类似于 volatile++ 这种复合操作不具有原子性。 2.1 volatile 的 happens before 语义123456789101112131415public class VolatileTest &#123; int a = 0; volatile boolean flag = false; public void writer() &#123; a = 1; //1 flag = true; //2 &#125; public void reader() &#123; if (flag) &#123; //3 int i = a; //4 &#125; &#125;&#125; 根据 happens before 规则，上面过程建立的 happens before 关系可以总结如下： 根据程序次序规则，1 happens before 2; 3 happens before 4。 根据 volatile 规则，2 happens before 3。 根据 happens before 的传递性规则，1 happens before 4。 对于上面代码 A 线程执行 writer() 方法之后，线程 B 线程执行 reader() 方法：A 线程写一个 volatile 变量后，B 线程读同一个 volatile 变量。A 线程在写volatile 变量之前所有可见的共享变量，在 B 线程读同一个 volatile 变量后，将立即变得对B线程可见。 2.2 volatile 读写的内存语义 ** volatile 写 ** 当写一个 volatile 变量时，JMM 会把该线程对应的本地内存中的共享变量刷新到主内存。 以上面代码为例，假设线程 A 首先执行 writer() 方法，随后线程 B 执行 reader() 方法，初始时两个线程的本地内存中的 flag 和 a 都是初始状态，如上图1步骤。** volatile 读 ** 当读一个 volatile 变量时，JMM 会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。 ** volatile 读写总结 ** 线程 A 写一个 volatile 变量，实质上是线程 A 向接下来将要读这个 volatile 变量的某个线程发出了（其对共享变量所在修改的）消息。 线程 B 读一个 volatile 变量，实质上是线程 B 接收了之前某个线程发出的（在写这个volatile 变量之前对共享变量所做修改的）消息。 线程A写一个 volatile 变量，随后线程 B 读这个 volatile 变量，这个过程实质上是线程A 通过主内存向线程 B 发送消息。 2.3 JMM 如何实现 volatile 写/读** 编译器重排序: **JMM 针对编译器制定的 volatile 重排序规则如下表： 从上表我们可以看出： 当第二个操作是 volatile 写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile 写之前的操作不会被编译器重排序到 volatile 写之后。 当第一个操作是 volatile 读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile 读之后的操作不会被编译器重排序到 volatile 读之前。 当第一个操作是 volatile 写，第二个操作是 volatile 读时，不能重排序。 ** 编译器重排序 ** 发现一个最优布置来最小化插入屏障的总数几乎不可能。为此，JMM 采取保守策略，下面是基于保守策略的 JMM 内存屏障插入策略： 在每个 volatile 写操作的前面插入一个 StoreStore 屏障。 在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。 在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。 在每个 volatile 读操作的后面插入一个 LoadStore 屏障。 ** 总结：**volatile 仅仅保证对单个 volatile 变量的读/写具有原子性，而锁的互斥执行的特性可以确保对整个临界区代码的执行具有原子性。在功能上，锁比 volatile 更强大；在可伸缩性和执行性能上，volatile 更有优势。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://www.xxzp.tech/tags/java/"},{"name":"并发","slug":"并发","permalink":"http://www.xxzp.tech/tags/并发/"}]},{"title":"java 内存模型分析","slug":"java 内存模型","date":"2018-08-26T16:00:00.000Z","updated":"2018-08-28T10:09:32.000Z","comments":true,"path":"2018/08/27/java 内存模型/","link":"","permalink":"http://www.xxzp.tech/2018/08/27/java 内存模型/","excerpt":"1. 概述在多核系统中，处理器一般都会有一层或者多层的缓存，这些的缓存通过加速数据访问和降低共享内存在总线上的通讯来提高CPU性能。这就导致并发编程必须面临两个关键问题：线程通信及线程同步。 线程通信 命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。 共享内存：线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。 消息传递的并发模型里：线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。 线程同步 指程序用于控制不同线程之间操作发生相对顺序的机制。Java 的并发模型采用的是共享内存模型，Java 线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。JMM 通过控制主内存与每个线程的本地内存之间的交互，来为 java 程序员提供内存可见性保证。","text":"1. 概述在多核系统中，处理器一般都会有一层或者多层的缓存，这些的缓存通过加速数据访问和降低共享内存在总线上的通讯来提高CPU性能。这就导致并发编程必须面临两个关键问题：线程通信及线程同步。 线程通信 命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。 共享内存：线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。 消息传递的并发模型里：线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。 线程同步 指程序用于控制不同线程之间操作发生相对顺序的机制。Java 的并发模型采用的是共享内存模型，Java 线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。JMM 通过控制主内存与每个线程的本地内存之间的交互，来为 java 程序员提供内存可见性保证。 2. JMM 抽象结构JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。在实现通信必须经过两个过程：线程A把本地内存A中更新过的共享变量刷新到主内存中去，线程B到主内存中去读取线程A之前已更新过的共享变量。其结构如下： 3. 多线程面临的问题由上面抽象结构可知，在多线程情况下必须面对两个问题：缓存一致性问题与重排序问题。缓存一致性问题：一个线程更新共享对象可能对其它线程来说是不可见的：共享对象被初始化在主存中。跑在CPU上的一个线程将这个共享对象读到CPU缓存中，然后修改了这个对象。只要CPU缓存没有被刷新会主存，对象修改后的版本对跑在其它CPU上的线程都是不可见的。这种方式可能导致每个线程拥有这个共享对象的私有拷贝，每个拷贝停留在不同的CPU缓存中。重排序问题：在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型： 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。 指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。 内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序： 而重排序都可能会导致多线程程序出现内存可见性问题。 4. JMM 实现语义4.1 as-if-serial不管怎么重排序，（单线程）程序的执行结果不能被改变。编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作可能被编译器和处理器重排序。as-if-serial 语义把单线程程序保护了起来，遵守 as-if-serial 语义的编译器，runtime 和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的。as-if-serial 语义使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。 4.2 happens beforeJSR-133 使用 happens-before 的概念来阐述操作之间的内存可见性。在 JMM 中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before 关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。happens-before 仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前。其具体规则如下： 程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。 监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。 volatile 变量规则：对一个 volatile 域的写，happens- before 于任意后续对这个 volatile 域的读。 传递性：如果 A happens- before B，且 B happens- before C，那么 A happens- before C。 4.3 内存屏障java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。其指令描述如下： 屏障类型 指令示例 说明 LoadLoad Barriers Load1; LoadLoad; Load2 确保Load1数据的装载，之前于Load2及所有后续装载指令的装载 StoreStore Barriers Store1; StoreStore; Store2 确保Store1数据对其他处理器可见（刷新到内存），之前于Store2及所有后续存储指令的存储 LoadStore Barriers Load1; LoadStore; Store2 确保Load1数据装载，之前于Store2及所有后续的存储指令刷新到内存 StoreLoad Barriers Store1; StoreLoad; Load2 确保Store1数据对其他处理器变得可见（指刷新到内存），之前于Load2及所有后续装载指令的装载。StoreLoad Barriers会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令 4.4 顺序一致性如果程序是正确同步的，程序的执行将具有顺序一致性（sequentially consistent）–即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同（马上我们将会看到，这对于程序员来说是一个极强的保证）。这里的同步是指广义上的同步，包括对常用同步原语（lock，volatile 和 final）的正确使用。其两大特性： 一个线程中的所有操作必须按照程序的顺序来执行。 所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。顺序一致性模型有一个单一的全局内存，这个内存通过一个左右摆动的开关可以连接到任意一个线程。同时，每一个线程必须按程序的顺序来执行内存读/写操作。如下图，最终保持B1-&gt;A1-&gt;A2-&gt;B2-&gt;A3-&gt;B3就能得到这个保证是因为顺序一致性内存模型中的每个操作必须立即对任意线程可见。 对于未同步或未正确同步的多线程程序，JMM 只提供最小安全性：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，null，false），JMM 保证线程读操作读取到的值不会无中生有（out of thin air）的冒出来。为了实现最小安全性，JVM 在堆上分配对象时，首先会清零内存空间，然后才会在上面分配对象（JVM内部会同步这两个操作）。因此，在以清零的内存空间（pre-zeroed memory）分配对象时，域的默认初始化已经完成了。 顺序一致性模型保证单线程内的操作会按程序的顺序执行，而 JMM 不保证单线程内的操作会按程序的顺序执行（比如上面正确同步的多线程程序在临界区内的重排序）。这一点前面已经讲过了，这里就不再赘述。 顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程能看到一致的操作执行顺序。这一点前面也已经讲过，这里就不再赘述。 JMM不保证对64位的 long 型和 double 型变量的读/写操作具有原子性，而顺序一致性模型保证对所有的内存读/写操作都具有原子性。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://www.xxzp.tech/tags/java/"},{"name":"并发","slug":"并发","permalink":"http://www.xxzp.tech/tags/并发/"}]},{"title":"java 对象分析","slug":"java 对象分析","date":"2018-08-25T16:00:00.000Z","updated":"2018-08-27T12:54:34.000Z","comments":true,"path":"2018/08/26/java 对象分析/","link":"","permalink":"http://www.xxzp.tech/2018/08/26/java 对象分析/","excerpt":"1. 常见 java 对象创建方式1234User user1 = User.class.newInstance();User user2 = (User) Class.forName(\"com.xxzp.ares.utils.reflect.TestReflect\").newInstance();User user3 = User.class.getConstructor().newInstance(1245L, \"test\");User user4 = (User) user1.clone();//需继承Cloneable与重写clone()方法","text":"1. 常见 java 对象创建方式1234User user1 = User.class.newInstance();User user2 = (User) Class.forName(\"com.xxzp.ares.utils.reflect.TestReflect\").newInstance();User user3 = User.class.getConstructor().newInstance(1245L, \"test\");User user4 = (User) user1.clone();//需继承Cloneable与重写clone()方法 2. Java 对象的创建过程java 语言中的数据类型主要分为基本类型和引用类型：基本类型：由 jvm 直接定义引用类型：类、接口、数组类和泛型参数，其中泛型会进行类型擦除，因此可以算作三种，类和接口直接生成对应的字节流，数组类是由 jvm 直接生成。 对象创建过程： 检查常量池中对应的类引用是否已加载、解析和初始化，如没有则执行类加载过程。 为新生对象分配内存:（指针碰撞，空闲列表）解决并发内存分配策略：CAS,本地线程分配缓冲 将分配到的对象在内存中都初始化为零值 设置对象信息：元数据信息，对象哈希码，gc分代信息，锁信息 执行方法，初始化对象 3. java 对象内存12345678class oopDesc &#123; friend class VMStructs; private: volatile markOop _mark; //运行时标识 union _metadata &#123; Klass* _klass; narrowKlass _compressed_klass; &#125; _metadata; //klass指针 对象在内存中存储的布局可以分为三块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding） 3.1 Object head：Mark Word 与 KlassMark Word: 主要包含对象自身运行时数据:哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机中分别为32个和64个Bits。 12345678910111213141516171832 bits: -------- hash:25 ------------&gt;| age:4 biased_lock:1 lock:2 (normal object) JavaThread*:23 epoch:2 age:4 biased_lock:1 lock:2 (biased object) size:32 ------------------------------------------&gt;| (CMS free block) PromotedObject*:29 ----------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)64 bits: -------- unused:25 hash:31 --&gt;| unused:1 age:4 biased_lock:1 lock:2 (normal object) JavaThread*:54 epoch:2 unused:1 age:4 biased_lock:1 lock:2 (biased object) PromotedObject*:61 ---------------------&gt;| promo_bits:3 -----&gt;| (CMS promoted object) size:64 -----------------------------------------------------&gt;| (CMS free block) unused:25 hash:31 --&gt;| cms_free:1 age:4 biased_lock:1 lock:2 (COOPs &amp;&amp; normal object) JavaThread*:54 epoch:2 cms_free:1 age:4 biased_lock:1 lock:2 (COOPs &amp;&amp; biased object) narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 -----&gt;| (COOPs &amp;&amp; CMS promoted object) unused:21 size:35 --&gt;| cms_free:1 unused:7 ------------------&gt;| (COOPs &amp;&amp; CMS free block) 对象锁信息如下： Klass: 对象指向它的类的元数据的指针,但是并不是所有的虚拟机实现都必须在对象数据上保留类型指针，查找对象的元数据信息并不一定要经过对象本身。如java数组，对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中无法确定数组的大小。 3.2 Instance Data实例数据部分是对象真正存储的有效信息，即程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的都需要记录下来。 这部分的存储顺序会受到虚拟机分配策略参数（FieldsAllocationStyle）和字段在Java源码中定义顺序的影响。HotSpot虚拟机 默认的分配策略为longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers），从分配策略中可以看出，相同宽度的字段总是被分配到一起。在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果 CompactFields参数值为true（默认为true），那子类之中较窄的变量也可能会插入到父类变量的空隙之中。 3.3 Padding对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是对象的大小必须是8字节的整数倍。对象头正好是8字节的倍数（1倍或者2倍），因此当对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。 指针压缩与内存对齐： 64 位的 Java 虚拟机中，对象头的标记字段占 64 位，而类型指针又占了 64 位。也就是说，每一个 Java 对象在内存中的额外开销就是 16 个字节。64 位 Java 虚拟机引入了压缩指针，将堆中原本 64 位的 Java 对象指针压缩成 32 位。对象头中的类型指针也会被压缩成 32 位，使得对象头的大小从 16 字节降至 12 字节。 Java 虚拟机重新分配字段的先后顺序，以达到内存对齐的目的。 12345678910public class PandingTestA &#123; private long a=10; private int b=20; private Long c=30L; private Integer d=10;&#125;public static void main(String[] args) &#123; System.out.println(ClassLayout.parseInstance(new PandingTestA()).toPrintable()); &#125; 对象内存结构测试结果： 123456789101112PandingTestA object internals:Disconnected from the target VM, address: '127.0.0.1:52668', transport: 'socket' OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 01 00 00 00 (00000001 00000000 00000000 00000000) (1) 4 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0) 8 4 (object header) 05 c1 00 f8 (00000101 11000001 00000000 11111000) (-134168315) 12 4 int PandingTestA.b 20 16 8 long PandingTestA.a 10 24 4 java.lang.Long PandingTestA.c 30 28 4 java.lang.Integer PandingTestA.d 10Instance size: 32 bytesSpace losses: 0 bytes internal + 0 bytes external = 0 bytes total 4. 对象的访问定位4.1 指针直接访问如果使用直接指针访问的话，Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址 4.2 句柄池访问如果使用句柄访问的话，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据的具体各自的地址信息 区别： 句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要被修改。 直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问的在Java中非常频繁，因此这类开销积小成多也是一项非常可观的执行成本。HotSpot 使用直接指针来访问方式进行对象访问","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://www.xxzp.tech/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.xxzp.tech/tags/jvm/"}]},{"title":"lambda 实践总结","slug":"lambda实践","date":"2018-08-22T16:00:00.000Z","updated":"2018-08-27T12:50:55.000Z","comments":true,"path":"2018/08/23/lambda实践/","link":"","permalink":"http://www.xxzp.tech/2018/08/23/lambda实践/","excerpt":"1. 按key值过滤：1234public static &lt;T&gt; Predicate&lt;T&gt; distinctByKey(Function&lt;? super T, Object&gt; function) &#123; Map&lt;Object, Boolean&gt; map = new ConcurrentHashMap&lt;&gt;(); return t -&gt; map.putIfAbsent(function.apply(t), Boolean.TRUE) == null;&#125;","text":"1. 按key值过滤：1234public static &lt;T&gt; Predicate&lt;T&gt; distinctByKey(Function&lt;? super T, Object&gt; function) &#123; Map&lt;Object, Boolean&gt; map = new ConcurrentHashMap&lt;&gt;(); return t -&gt; map.putIfAbsent(function.apply(t), Boolean.TRUE) == null;&#125; 示例： 12345678910public static void main(String[] args) &#123; User user1 = new User(1L, \"test1\"); User user2 = new User(2L, \"test2\"); User user3 = new User(1L, \"test1\"); List&lt;User&gt; users = Arrays.asList(user1, user2, user3); List&lt;User&gt; userList = users.stream() .filter(CollectionUtils.distinctByKey(u -&gt; u.getUserId().toString() + u.getUserName())) .collect(Collectors.toList()); userList.forEach(System.out::println);&#125; 输出结果如下： 12User:&#123;userId:1, userName:test1&#125;User:&#123;userId:2, userName:test2&#125; 2. lambda自定义捕获异常在如下场景中，我们使用 lambda表达式处理异常，代码就显得很不优雅。 123456789101112131415161718192021222324252627public static void main(String[] args) &#123; User user1 = new User(1L, \"test1\"); User user2 = new User(2L, \"test2\"); User user3 = new User(3L, \"test3\"); List&lt;User&gt; users = Arrays.asList(user1, user2, user3); List&lt;String&gt; strings = users.stream().map(u -&gt; &#123; try &#123; return getUserName(u); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return \"\"; &#125;).collect(Collectors.toList());&#125;private static String getUserName(User user) throws Exception &#123; if (user.getUserId() == 1) &#123; throw new Exception(\"test exception\"); &#125; return \"test\";&#125;private static void printUserInfo(User user) throws Exception &#123; if (user.getUserId() == 1) &#123; throw new Exception(\"test exception\"); &#125; System.out.println(user);&#125; 优化：使用函数式接口对异常进行封装处理 1234567891011121314151617181920212223242526272829303132333435363738public class ExceptionsUtils &#123; private final static Logger logger = LoggerFactory.getLogger(ExceptionsUtils.class); @FunctionalInterface public interface UncheckedFunction&lt;T, R&gt; &#123; R apply(T t) throws Exception; &#125; //带默认值的异常封装 public static &lt;T, R&gt; Function&lt;T, R&gt; of(UncheckedFunction&lt;T, R&gt; function, R defaultR) &#123; Objects.requireNonNull(function); return t -&gt; &#123; try &#123; return function.apply(t); &#125; catch (Exception ex) &#123; logger.error(\"处理异常\", ex); return defaultR; &#125; &#125;; &#125; @FunctionalInterface public interface UncheckedConsumer&lt;T, E extends Exception&gt; &#123; void accept(T t) throws E; &#125; //不带默认值的异常封装 public static &lt;T&gt; Consumer&lt;T&gt; of(UncheckedConsumer&lt;T, Exception&gt; consumer) &#123; return i -&gt; &#123; try &#123; consumer.accept(i); &#125; catch (Exception ex) &#123; logger.error(\"处理异常\", ex); &#125; &#125;; &#125;&#125; 优化后客户端处理： 1234567//带默认值List&lt;String&gt; strings = users.stream() .map(ExceptionsUtils.of(u -&gt; getUserName(u), \"exception handle\")) .collect(Collectors.toList());//不带默认值users.forEach(ExceptionsUtils.of(u-&gt;printUserInfo(u)));","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://www.xxzp.tech/tags/java/"},{"name":"lambda","slug":"lambda","permalink":"http://www.xxzp.tech/tags/lambda/"}]},{"title":"lambda实现机制分析","slug":"lambda实现机制分析","date":"2018-08-21T16:00:00.000Z","updated":"2018-08-27T12:50:37.000Z","comments":true,"path":"2018/08/22/lambda实现机制分析/","link":"","permalink":"http://www.xxzp.tech/2018/08/22/lambda实现机制分析/","excerpt":"1. lambda代码与反编译1234567891011121314151617public class Lambda &#123; public static void main(String[] args) &#123; println1(); println2(); &#125; private static void println1() &#123; Consumer&lt;String&gt; consumer = System.out::println; consumer.accept(\"test\"); &#125; private static void println2() &#123; Consumer&lt;String&gt; consumer = str -&gt; System.out.println(str); consumer.accept(\"test\"); &#125;&#125;","text":"1. lambda代码与反编译1234567891011121314151617public class Lambda &#123; public static void main(String[] args) &#123; println1(); println2(); &#125; private static void println1() &#123; Consumer&lt;String&gt; consumer = System.out::println; consumer.accept(\"test\"); &#125; private static void println2() &#123; Consumer&lt;String&gt; consumer = str -&gt; System.out.println(str); consumer.accept(\"test\"); &#125;&#125; javap -c -p -v Lambda 查看反编译： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697Classfile /Users/ares/ares/ares/src/main/java/com/xxzp/ares/utils/reflect/Lambda.class Last modified 2018-8-23; size 1371 bytes MD5 checksum 620c826160c973c61dbf9d1b8fd37ad3 Compiled from \"Lambda.java\"public class com.xxzp.ares.utils.reflect.Lambda minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: ..........//省略常量池&#123; public com.xxzp.ares.utils.reflect.Lambda(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.\"&lt;init&gt;\":()V 4: return LineNumberTable: line 5: 0 public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=0, locals=1, args_size=1 0: invokestatic #2 // Method println1:()V 3: invokestatic #3 // Method println2:()V 6: return LineNumberTable: line 8: 0 line 9: 3 line 10: 6 private static void println1(); descriptor: ()V flags: ACC_PRIVATE, ACC_STATIC Code: stack=2, locals=1, args_size=0 0: getstatic #4 // Field java/lang/System.out:Ljava/io/PrintStream; 3: dup 4: invokevirtual #5 // Method java/lang/Object.getClass:()Ljava/lang/Class; 7: pop 8: invokedynamic #6, 0 // InvokeDynamic #0:accept:(Ljava/io/PrintStream;)Ljava/util/function/Consumer; 13: astore_0 14: aload_0 15: ldc #7 // String test 17: invokeinterface #8, 2 // InterfaceMethod java/util/function/Consumer.accept:(Ljava/lang/Object;)V 22: return LineNumberTable: line 13: 0 line 14: 14 line 15: 22 private static void println2(); descriptor: ()V flags: ACC_PRIVATE, ACC_STATIC Code: stack=2, locals=1, args_size=0 0: invokedynamic #9, 0 // InvokeDynamic #1:accept:()Ljava/util/function/Consumer; 5: astore_0 6: aload_0 7: ldc #7 // String test 9: invokeinterface #8, 2 // InterfaceMethod java/util/function/Consumer.accept:(Ljava/lang/Object;)V 14: return LineNumberTable: line 18: 0 line 19: 6 line 20: 14 private static void lambda$println2$0(java.lang.String); descriptor: (Ljava/lang/String;)V flags: ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC Code: stack=2, locals=1, args_size=1 0: getstatic #4 // Field java/lang/System.out:Ljava/io/PrintStream; 3: aload_0 4: invokevirtual #10 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 7: return LineNumberTable: line 18: 0&#125;SourceFile: \"Lambda.java\"InnerClasses: public static final #66= #65 of #69; //Lookup=class java/lang/invoke/MethodHandles$Lookup of class java/lang/invoke/MethodHandlesBootstrapMethods: 0: #32 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite; Method arguments: #33 (Ljava/lang/Object;)V #34 invokevirtual java/io/PrintStream.println:(Ljava/lang/String;)V #35 (Ljava/lang/String;)V 1: #32 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite; Method arguments: #33 (Ljava/lang/Object;)V #40 invokestatic com/xxzp/ares/utils/reflect/Lambda.lambda$println2$0:(Ljava/lang/String;)V #35 (Ljava/lang/String;)V 2. 分析2.1 方法调用指令 invokespecial: 调用实例构造方法，私有方法和父类方法 invokestatic: 调用静态方法 invokevirtual: 调用虚方法 invokedynamic: 运行时动态解析调用，主要是为了支持动态语言的方法调用在jdk7中增加 invokeinterface: 调用接口方法，在运行时再确定一个实现此接口的对象 从上面可以看到，Consumer.ccept 是通过 invokedynamic 去调用的，第一次执行 invokedynamic 指令时，Java 虚拟机会调用该指令所对应的启动方法（BootStrap Method），来生成前面提到的调用点，并且将之绑定至该 invokedynamic 指令中。在之后的运行过程中，Java 虚拟机则会直接调用绑定的调用点所链接的方法句柄。 2.2 BootstrapMethods与MethodHandleBootstrapMethods： 启动方法是用方法句柄来指定的，这个方法句柄指向一个返回类型为调用点的静态方法，由上面可看到invokedynamic最终通过LambdaMetafactory.metafactory找到目标对象。 10: #32 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite; MethodHandle方法句柄：强类型的，能够被直接执行的引用，该引用可以指向常规的静态方法或者实例方法，也可以指向构造器或者字段。 12345CONSTANT_MethodHandle_info &#123; u1 tag; u1 reference_kind; u2 reference_index;&#125; tag: 标记项值为CONSTANT_MethodHandle reference_kind：其值必须在1到9的范围内，表示此方法句柄的类型(MethodType)，即其字节码的行为。 Field：1 (REF_getField), 2 (REF_getStatic), 3 (REF_putField), 4 (REF_putStatic) Method：5 (REF_invokeVirtual), 6 (REF_invokeStatic), 7 (REF_invokeSpecial), 8 (REF_newInvokeSpecial), 9 (REF_invokeInterface) reference_index：值必须是constant_pool表的有效索引 2.3 LambdaMetafactory1234567891011121314public static CallSite metafactory(MethodHandles.Lookup caller, String invokedName, MethodType invokedType, MethodType samMethodType, MethodHandle implMethod, MethodType instantiatedMethodType)throws LambdaConversionException &#123; AbstractValidatingLambdaMetafactory mf; mf = new InnerClassLambdaMetafactory(caller, invokedType, invokedName, samMethodType, implMethod, instantiatedMethodType, false, EMPTY_CLASS_ARRAY, EMPTY_MT_ARRAY); mf.validateMetafactoryArgs(); return mf.buildCallSite();&#125; 从上面代码可看到，metafactory就是核心方法，该方法通过InnerClassLambdaMetafactory每个lambda调用点动态创建一个类内部类的类。 3. 方法引用123456789private static void println1() &#123; Consumer&lt;String&gt; consumer = System.out::println; consumer.accept(\"test\");&#125; private static void println2() &#123; Consumer&lt;String&gt; consumer = str -&gt; System.out.println(str); consumer.accept(\"test\"); &#125; 反汇编结果如下： 1234567891011121314//println1private static void println1(); descriptor: ()V Code: 0: getstatic #4 // Field java/lang/System.out:Ljava/io/PrintStream; 3: dup 4: invokevirtual #5 // Method java/lang/Object.getClass:()Ljava/lang/Class; 7: pop 8: invokedynamic #6, 0 // InvokeDynamic #0:accept:(Ljava/io/PrintStream;)Ljava/util/function/Consumer; 13: astore_0 14: aload_0 15: ldc #7 // String test 17: invokeinterface #8, 2 // InterfaceMethod java/util/function/Consumer.accept:(Ljava/lang/Object;)V 22: return 12345678910111213141516171819 //println2 private static void println2(); descriptor: ()V Code: 0: invokedynamic #9, 0 // InvokeDynamic #1:accept:()Ljava/util/function/Consumer; 5: astore_0 6: aload_0 7: ldc #7 // String test 9: invokeinterface #8, 2 // InterfaceMethod java/util/function/Consumer.accept:(Ljava/lang/Object;)V 14: return private static void lambda$println2$0(java.lang.String); descriptor: (Ljava/lang/String;)V Code: 0: getstatic #4 // Field java/lang/System.out:Ljava/io/PrintStream; 3: aload_0 4: invokevirtual #10 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 7: return&#125; 从上现可看到，System.out::println 不会再单独生成一个方法，而 str -&gt; System.out.println(str) 会生成一个 lambda$println2$0 用来保存 Lambda 表达式的内容，其参数列表不仅包含原本 Lambda 表达式的参数，还包含它所捕获的变量。Lambda 表达式是否捕获其他变量，启动方法生成的适配器类以及所链接的方法句柄皆不同。如果该 Lambda 表达式没有捕获其他变量，那么可以认为它是上下文无关的。因此，启动方法将新建一个适配器类的实例，并且生成一个特殊的方法句柄，始终返回该实例。如果该 Lambda 表达式捕获了其他变量，那么每次执行该 invokedynamic 指令，我们都要更新这些捕获了的变量，以防止它们发生了变化。其实二者的区别主要在于是否对变量进行捕获。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://www.xxzp.tech/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.xxzp.tech/tags/jvm/"},{"name":"lambda","slug":"lambda","permalink":"http://www.xxzp.tech/tags/lambda/"}]},{"title":"反射与动态代理","slug":"反射与动态代理","date":"2018-08-20T16:00:00.000Z","updated":"2018-08-27T12:50:37.000Z","comments":true,"path":"2018/08/21/反射与动态代理/","link":"","permalink":"http://www.xxzp.tech/2018/08/21/反射与动态代理/","excerpt":"1. 反射概述Java反射机制可以动态地获取类的结构，动态地调用对象的方法，是java语言一个动态化的机制。其功能场景： 运行时构造一个类的对象 运行时获取一个类信息，如方法，属性 实现动态代理，很多框架都有基于动态代理实现 1.1 反射获取类信息获取类信息方式： 1234Class&lt;TestReflect&gt; clazz1 = TestReflect.class;Class&lt;?&gt; clazz2 = Class.forName(\"com.xxzp.ares.utils.reflect.TestReflect\");TestReflect testReflect = new TestReflect();Class&lt;?&gt; clazz3 = testReflect.getClass();","text":"1. 反射概述Java反射机制可以动态地获取类的结构，动态地调用对象的方法，是java语言一个动态化的机制。其功能场景： 运行时构造一个类的对象 运行时获取一个类信息，如方法，属性 实现动态代理，很多框架都有基于动态代理实现 1.1 反射获取类信息获取类信息方式： 1234Class&lt;TestReflect&gt; clazz1 = TestReflect.class;Class&lt;?&gt; clazz2 = Class.forName(\"com.xxzp.ares.utils.reflect.TestReflect\");TestReflect testReflect = new TestReflect();Class&lt;?&gt; clazz3 = testReflect.getClass(); 使用示例： 12345678910111213public static void main(String[] args) throws Exception &#123; Class&lt;?&gt; clazz1 = TestReflect.class; System.out.println(\"clazz1:\" + clazz1.getName()); System.out.println(\"clazz1类加载器：\" + clazz1.getClassLoader().getClass().getName()); Class&lt;?&gt; clazz2 = Class.forName(\"com.xxzp.ares.utils.reflect.TestReflect\"); System.out.println(\"clazz2:\" + clazz2.getName()); TestReflect testReflect = new TestReflect(); Class&lt;?&gt; clazz3 = testReflect.getClass(); System.out.println(\"clazz3:\" + clazz3.getName()); if (clazz1 == clazz2 &amp;&amp; clazz2 == clazz3) &#123; System.out.println(\"clazz1==clazz2==clazz3\"); &#125;&#125; 1.2 基本使用反射操作主要涉及java.lang.Class类和java.lang.reflect反射包下的类。 java.lang.reflect.Constructor： 获取构造方法，包括自己声名与父类的构造方法，可以实现动态构建对象 123456789//Class类中//获取所有构造方法包含父类public Constructor&lt;?&gt;[] getConstructors() throws SecurityException//获取自己声明的构造方法public Constructor&lt;?&gt;[] getDeclaredConstructors() throws SecurityException//获取含特定参数的构造方法包含父类public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)throws NoSuchMethodException, SecurityException//获取含特定参数自己声明的构造方法public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)throws NoSuchMethodException, SecurityException 使用示例： 12345678910111213private static void testConstructor() throws Exception &#123; Class&lt;?&gt; clazz = User.class; Constructor&lt;?&gt;[] allConstructors = clazz.getConstructors(); Constructor&lt;?&gt;[] allDeclaredConstructors = clazz.getDeclaredConstructors(); Constructor&lt;?&gt; constructor = clazz.getConstructor(Long.class, String.class); Constructor&lt;?&gt; declaredConstructor = clazz.getDeclaredConstructor(Long.class, String.class); Arrays.stream(allConstructors).forEach(System.out::println); Arrays.stream(allDeclaredConstructors).forEach(System.out::println); System.out.println(constructor); System.out.println(declaredConstructor); User user=(User) constructor.newInstance(1245L,\"test\"); System.out.println(user);&#125; java.lang.reflect.Field：使用成员变量 1234public Field[] getFields() throws SecurityExceptionpublic Field[] getDeclaredFields() throws SecurityExceptionpublic Field getField(String name)throws NoSuchFieldException, SecurityException public Field getDeclaredField(String name)throws NoSuchFieldException, SecurityException 使用示例： 1234567891011private static void testField() throws Exception &#123; Class&lt;?&gt; clazz = User.class; Field[] fields = clazz.getDeclaredFields(); Arrays.stream(fields).forEach(System.out::println); Constructor&lt;?&gt; constructor = clazz.getConstructor(Long.class, String.class); User user = (User) constructor.newInstance(1245L, \"test\"); Field declaredField = clazz.getDeclaredField(\"userName\"); declaredField.setAccessible(true); Object object = declaredField.get(user); System.out.println(object);&#125; java.lang.reflect.Method：使用成员方法 12public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)public Method getMethod(String name, Class&lt;?&gt;... parameterTypes) 使用示例： 12345678private static void testMethod() throws Exception &#123; Class&lt;?&gt; clazz = User.class; Method[] methods = clazz.getDeclaredMethods(); Arrays.stream(methods).forEach(System.out::println); Method method = clazz.getMethod(\"getUser\", Long.class, String.class); Object object = method.invoke(new User(), 12345L, \"ares\"); System.out.println(object);&#125; 2. 理解反射调用的实现机制(method.invoke(Object obj, Object… args))123456789101112131415@CallerSensitivepublic Object invoke(Object obj, Object... args)throws IllegalAccessException, IllegalArgumentException,InvocationTargetException&#123; if (!override) &#123; if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123; Class&lt;?&gt; caller = Reflection.getCallerClass(); checkAccess(caller, clazz, obj, modifiers); &#125; &#125; // read volatile MethodAccessor ma = methodAccessor; if (ma == null) &#123; ma = acquireMethodAccessor(); &#125; return ma.invoke(obj, args);&#125; 通过源码可以看到，invoke()其实是通过 MethodAccessor 来处理，MethodAccessor 是一个接口，有两个实现：一个通过本地方法来实现反射调用，另一个则使用了委派模式。每个 Method 实例的第一次反射调用都会生成一个委派实现，它所委派的具体实现便是一个本地实现。对于本地实现，jvm内部之后，即可获取 Method 实例所指向方法的具体地址。这时候，反射调用无非就是将传入的参数准备好，然后调用进入目标方法。另外，Java 的反射调用机制还设立了另一种动态生成字节码的实现，直接使用 invoke 指令来调用目标方法。采用委派实现是为了能够在本地实现以及动态实现中切换。动态实现和本地实现两者在不同的场景其效率不同，多次调用则动态实现效率要高，因为无需多次切换，如调一次则本地效率要高，主要因为生成字节码耗时。jvm 默认设置阈值为 15 次则转换为动态，可通过-Dsun.reflect.inflationThreshold 调整 3. JDK动态代理接口 123public interface ProxyInterface &#123; String test(String str);&#125; 实现类 1234567public class ProxyInterfaceImpl implements ProxyInterface&#123; @Override public String test(String str) &#123; return \"this is dynamic:\" + str; &#125;&#125; 动态代理类 1234567891011public class DynamicProxy &#123; private static ProxyInterface getProxy(Class&lt;ProxyInterfaceImpl&gt; implClass) &#123; return (ProxyInterface) Proxy.newProxyInstance(implClass.getClassLoader(), implClass.getInterfaces(), (proxy, method, args) -&gt; method.invoke(implClass.newInstance(), args)); &#125; public static void main(String[] args) &#123; ProxyInterface proxyInterface = getProxy(ProxyInterfaceImpl.class); System.out.println(proxyInterface.test(\"test\")); &#125;&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://www.xxzp.tech/tags/java/"}]},{"title":"java类加载机制","slug":"java类加载","date":"2018-08-19T16:00:00.000Z","updated":"2018-08-27T12:50:37.000Z","comments":true,"path":"2018/08/20/java类加载/","link":"","permalink":"http://www.xxzp.tech/2018/08/20/java类加载/","excerpt":"1. 类加载过程(加载—&gt;链接—&gt;初始化)加载： 是指查找字节流，并且据此创建类的过程。链接： 是指将创建成的类合并至 Java 虚拟机中，使之能够执行的过程。它可分为验证、准备以及解析三个阶段。 验证：确保被加载类能够满足 Java 虚拟机的约束条件。 准备：为被加载类的静态字段分配内存。Java 代码中对静态字段的具体初始化，则会在稍后的初始化阶段中进行。 解析：将符号引用解析成为实际引用，如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载 初始化： 是指给常量值的字段赋值，以及执行 &lt; clinit &gt; 方法的过程。Java 虚拟机会通过加锁来确保类的 &lt; clinit &gt; 方法仅被执行一次。初始化完成之后，类才正式成为可执行的状态。","text":"1. 类加载过程(加载—&gt;链接—&gt;初始化)加载： 是指查找字节流，并且据此创建类的过程。链接： 是指将创建成的类合并至 Java 虚拟机中，使之能够执行的过程。它可分为验证、准备以及解析三个阶段。 验证：确保被加载类能够满足 Java 虚拟机的约束条件。 准备：为被加载类的静态字段分配内存。Java 代码中对静态字段的具体初始化，则会在稍后的初始化阶段中进行。 解析：将符号引用解析成为实际引用，如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载 初始化： 是指给常量值的字段赋值，以及执行 &lt; clinit &gt; 方法的过程。Java 虚拟机会通过加锁来确保类的 &lt; clinit &gt; 方法仅被执行一次。初始化完成之后，类才正式成为可执行的状态。 2. 类加载器类型启动类加载器(Bootstrap ClassLoader)：启动类加载器主要加载JVM自身需要的类，用C++语言实现，是虚拟机自身的一部分，它负责将 /lib路径下的核心类库或-Xbootclasspath参数指定的路径下的jar包加载到内存中。 扩展类加载器(Extension ClassLoader)： sun.misc.Launcher$ExtClassLoader类，Java语言实现，是Launcher的静态内部类，它负责加载/lib/ext目录下或者由系统变量-Djava.ext.dir指定位路径中的类库，可以直接使用标准扩展类加载器。 应用程序类加载器(Application ClassLoader)：sun.misc.Launcher$AppClassLoader。它负责加载系统类路径java -classpath或-D java.class.path 指定路径下的类库，也就是我们经常用到的classpath路径，开发者可以直接使用系统类加载器，一般情况下该类加载是程序中默认的类加载器，通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器。 自定义类加载器：来实现特殊的加载方式，在对 class 文件进行加密，加载时再利用自定义的类加载器对其解密等，可以通过继承java.lang.ClassLoader 来实现。自定义类加载器示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class TestClassLoad extends ClassLoader &#123; public TestClassLoad() &#123; &#125; public TestClassLoad(ClassLoader parent) &#123; super(parent); &#125; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; File file = new File(\"com/example/jpa/classload/User.class\"); try &#123; byte[] bytes = getClassBytes(file); return this.defineClass(name, bytes, 0, bytes.length); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return super.findClass(name); &#125; private byte[] getClassBytes(File file) throws Exception &#123; WritableByteChannel writableByteChannel = null; ByteArrayOutputStream outStream = new ByteArrayOutputStream(); try (FileInputStream inputStream = new FileInputStream(file)) &#123; FileChannel channel = inputStream.getChannel(); writableByteChannel = Channels.newChannel(outStream); ByteBuffer buffer = ByteBuffer.allocate(1024); while (channel.read(buffer) &gt; 0) &#123; buffer.flip(); writableByteChannel.write(buffer); buffer.clear(); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; closeChannel(writableByteChannel); &#125; return outStream.toByteArray(); &#125; private void closeChannel(WritableByteChannel writableByteChannel) &#123; if (Objects.isNull(writableByteChannel)) &#123; return; &#125; try &#123; writableByteChannel.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 测试如下： 12Class&lt;?&gt; clazz = Class.forName(\"com/example/jpa/classload/User\", true, new TestClassLoad());Object object = clazz.newInstance(); 3. 双亲委派模型其模型如下： 双亲委派模型的实现源码如下(jdk8)： 123456789101112131415161718192021222324252627282930313233protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; synchronized (getClassLoadingLock(name)) &#123; // First, check if the class has already been loaded Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; if (parent != null) &#123; c = parent.loadClass(name, false); &#125; else &#123; c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125;&#125; 其加载方式如下：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的加载器都是如此，因此所有的类加载请求都会传给顶层的启动类加载器，只有当父加载器无法完成该加载请求时，子加载器才会尝试自己去加载。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://www.xxzp.tech/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.xxzp.tech/tags/jvm/"}]},{"title":"JPA深入","slug":"jpa深入","date":"2018-08-18T16:00:00.000Z","updated":"2018-08-27T12:50:37.000Z","comments":true,"path":"2018/08/19/jpa深入/","link":"","permalink":"http://www.xxzp.tech/2018/08/19/jpa深入/","excerpt":"1. JpaRepository继承关系JpaRepository继承了PagingAndSortingRepository和QueryByExampleExecutor，具体描述如下：PagingAndSortingRepository 支持分页与排序，包含方法: 123Iterable&lt;T&gt; findAll(Sort sort);//Pageable包含分页信息Page&lt;T&gt; findAll(Pageable pageable); 使用示例如下： 123Sort sort = new Sort(Direction.DESC, \"id\");PageRequest pageRequest = new PageRequest(pageNo, pageSize, sort);Page page = userRepository.findAll(pageRequest);","text":"1. JpaRepository继承关系JpaRepository继承了PagingAndSortingRepository和QueryByExampleExecutor，具体描述如下：PagingAndSortingRepository 支持分页与排序，包含方法: 123Iterable&lt;T&gt; findAll(Sort sort);//Pageable包含分页信息Page&lt;T&gt; findAll(Pageable pageable); 使用示例如下： 123Sort sort = new Sort(Direction.DESC, \"id\");PageRequest pageRequest = new PageRequest(pageNo, pageSize, sort);Page page = userRepository.findAll(pageRequest); QueryByExampleExecutor 实现动态条件查询： 12345678public interface QueryByExampleExecutor&lt;T&gt; &#123; &lt;S extends T&gt; Optional&lt;S&gt; findOne(Example&lt;S&gt; example); &lt;S extends T&gt; Iterable&lt;S&gt; findAll(Example&lt;S&gt; example); &lt;S extends T&gt; Iterable&lt;S&gt; findAll(Example&lt;S&gt; example, Sort sort); &lt;S extends T&gt; Page&lt;S&gt; findAll(Example&lt;S&gt; example, Pageable pageable); &lt;S extends T&gt; long count(Example&lt;S&gt; example); &lt;S extends T&gt; boolean exists(Example&lt;S&gt; example);&#125; 使用示例如下： 123456UserEntity entity=new UserEntity();entity.setUserId(null);entity.setUserName(\"aa\");ExampleMatcher matcher = ExampleMatcher.matching().withIgnoreNullValues();Example&lt;CompanyAccountEntity&gt; example = Example.of(entity, matcher);List&lt;UserEntity&gt; entities = userRepository.findAll(example);//可结合分页使用 CrudRepository 提供了公共的通用的CRUD方法,其主要是Spring Data兼容NoSQL而进行的抽象封装： 1234567891011121314@NoRepositoryBeanpublic interface CrudRepository&lt;T, ID&gt; extends Repository&lt;T, ID&gt; &#123; &lt;S extends T&gt; S save(S entity); &lt;S extends T&gt; Iterable&lt;S&gt; saveAll(Iterable&lt;S&gt; entities); Optional&lt;T&gt; findById(ID id); boolean existsById(ID id); Iterable&lt;T&gt; findAll(); Iterable&lt;T&gt; findAllById(Iterable&lt;ID&gt; ids); long count(); void deleteById(ID id); void delete(T entity); void deleteAll(Iterable&lt;? extends T&gt; entities); void deleteAll();&#125; 2. SimpleJpaRepositorySimpleJpaRepository是JPA整个关联数据库的所有Repository的接口实现类: 123456789101112131415161718@Repository@Transactional(readOnly = true)public class SimpleJpaRepository&lt;T, ID&gt; implements JpaRepository&lt;T, ID&gt;,JpaSpecificationExecutor&lt;T&gt; &#123; private static final String ID_MUST_NOT_BE_NULL = \"The given id must not be null!\"; private final JpaEntityInformation&lt;T, ?&gt; entityInformation; private final EntityManager em; private final PersistenceProvider provider; private @Nullable CrudMethodMetadata metadata; .... @Transactional public void delete(T entity) &#123; Assert.notNull(entity, \"The entity must not be null!\"); em.remove(em.contains(entity) ? entity : em.merge(entity)); &#125;&#125; 从其实现上看，SimpleJpaRepository通过EntityManger进行实体的操作，JpaEntityInforMation 保存着实体的相关信息以及crud 方法的元数据等等。 3. 查询方法生成基础架构中有个根据方法名的查询生成器机制，对于在存储库的实体上构建约束查询很有用，该机制方法的前缀 find…By、read…By、query…By、count…By 和 get…By 关联对应实体字段。 12345678public class PartTree implements Streamable&lt;OrPart&gt; &#123; private static final String KEYWORD_TEMPLATE = \"(%s)(?=(\\\\p&#123;Lu&#125;|\\\\P&#123;InBASIC_LATIN&#125;))\"; private static final String QUERY_PATTERN = \"find|read|get|query|stream\"; private static final String COUNT_PATTERN = \"count\"; private static final String EXISTS_PATTERN = \"exists\"; private static final String DELETE_PATTERN = \"delete|remove\"; private static final Pattern PREFIX_TEMPLATE = Pattern.compile( \"^(\" + QUERY_PATTERN + \"|\" + COUNT_PATTERN + \"|\" + EXISTS_PATTERN + \"|\" + DELETE_PATTERN + \")((\\\\p&#123;Lu&#125;.*?))??By\"); 解析方法的实际结果取决于创建查询的持久性存储,表达式通常是可以连接运算符的属性遍历，如：And,Or Between、LessThan、GreaterThan、Like等还包含IgnoreCase，具体关键字可查看public static enum Type。 4. @Query使用查询示例： 12345@Query(value = \"SELECT u FROM user u\", nativeQuery = true)List&lt;UserEntity&gt; findUserEntities();@Query(value = \"SELECT u FROM user u\", nativeQuery = true)Stream&lt;UserEntity&gt; findUserEntitiesStream(); 更新示例： 1234@Transactional@Modifying(clearAutomatically = true)@Query(value = \"UPDATE user SET user_name=?1 WHERE id=?2\",nativeQuery = true)int updateUserNameById(String userName,Long id);","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://www.xxzp.tech/tags/java/"},{"name":"JPA","slug":"JPA","permalink":"http://www.xxzp.tech/tags/JPA/"},{"name":"spring boot","slug":"spring-boot","permalink":"http://www.xxzp.tech/tags/spring-boot/"}]},{"title":"JPA初步","slug":"jpa简单实践","date":"2018-08-17T16:00:00.000Z","updated":"2018-09-05T15:25:58.000Z","comments":true,"path":"2018/08/18/jpa简单实践/","link":"","permalink":"http://www.xxzp.tech/2018/08/18/jpa简单实践/","excerpt":"1. 概述Spring data jpa是JPA规范的再次封装抽象，底层使用了Hibernate的JPA技术实现，引用JPQL（Java Persistence Query Language查询语言，属于 Spring 的整个生态体系的一部分。Spring Data JPA作为Spring生态的部分，使用起来比较方便，加快了开发的效率，使开发者不需要关系和配置更多的东西，完全可以沉浸在 Spring 的完整生态标准的实现下，上手简单、开发效率高，对象的支持比较好，有较大的灵活性，市场的认可度越来越高。 2. Spring boot集成JPAgradle添加依赖： 123456dependencies &#123; compile('org.springframework.boot:spring-boot-starter-web') compile('org.springframework.boot:spring-boot-starter-data-jpa') runtime('mysql:mysql-connector-java') testCompile('org.springframework.boot:spring-boot-starter-test')&#125;","text":"1. 概述Spring data jpa是JPA规范的再次封装抽象，底层使用了Hibernate的JPA技术实现，引用JPQL（Java Persistence Query Language查询语言，属于 Spring 的整个生态体系的一部分。Spring Data JPA作为Spring生态的部分，使用起来比较方便，加快了开发的效率，使开发者不需要关系和配置更多的东西，完全可以沉浸在 Spring 的完整生态标准的实现下，上手简单、开发效率高，对象的支持比较好，有较大的灵活性，市场的认可度越来越高。 2. Spring boot集成JPAgradle添加依赖： 123456dependencies &#123; compile('org.springframework.boot:spring-boot-starter-web') compile('org.springframework.boot:spring-boot-starter-data-jpa') runtime('mysql:mysql-connector-java') testCompile('org.springframework.boot:spring-boot-starter-test')&#125; application.yml文件中配置相关配置,采用hikari数据库连接池: 1234567spring: datasource: url: jdbc:mysql://localhost:3306/test username: root password: root hikari: driver-class-name: com.mysql.jdbc.Driver DataSourceConfig如下： 1234567891011@Configuration@ConfigurationProperties(prefix = \"spring.datasource.hikari\")@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)public class DataSourceConfig extends HikariConfig &#123; HikariDataSource createDataSource(String jdbcUrl, String username, String password) &#123; this.setJdbcUrl(jdbcUrl); this.setUsername(username); this.setPassword(password); return new HikariDataSource(this); &#125;&#125; 此处采用DataSourceConfig作为数据源配置的基类，因此有@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)限制在多数据源时加载不同的数据源配置。如下为使用的数据源： 1234567891011121314151617181920212223242526272829303132333435363738@Configuration@ConfigurationProperties(prefix = \"spring.datasource\")public class DataSourceFactory &#123; private String url; private String userName; private String passWord; @Bean @Primary public DataSource testDataSource(DataSourceConfig dataSourceConfig) &#123; return dataSourceConfig.createDataSource(url, userName, passWord); &#125; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public String getPassWord() &#123; return passWord; &#125; public void setPassWord(String passWord) &#123; this.passWord = passWord; &#125;&#125; 3 使用创建实体对象： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@Entity@Tablepublic class UserEntity &#123; @Id @Basic @Column @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column private Long userId; @Column private String userName; @Column private Timestamp ctime; @Column private Timestamp mtime; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public Long getUserId() &#123; return userId; &#125; public void setUserId(Long userId) &#123; this.userId = userId; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public Timestamp getCtime() &#123; return ctime; &#125; public void setCtime(Timestamp ctime) &#123; this.ctime = ctime; &#125; public Timestamp getMtime() &#123; return mtime; &#125; public void setMtime(Timestamp mtime) &#123; this.mtime = mtime; &#125;&#125; 创建Repository：1234@Repositorypublic interface UserRepository extends JpaRepository&lt;UserEntity, Long&gt; &#123;&#125; 测试：12345678910111213141516171819@RestControllerpublic class UserController &#123; @Resource private UserRepository userRepository; @GetMapping(\"/getAll\") public List&lt;UserEntity&gt; getAll() &#123; return userRepository.findAll(); &#125; @PostMapping(\"/save\") public UserEntity saveUser() &#123; UserEntity entity = new UserEntity(); entity.setUserId(3L); entity.setUserName(\"a\"); return userRepository.save(entity); &#125;&#125; 4. JpaRepository初步1234567891011121314@NoRepositoryBeanpublic interface JpaRepository&lt;T, ID&gt; extends PagingAndSortingRepository&lt;T, ID&gt;, QueryByExampleExecutor&lt;T&gt; &#123; List&lt;T&gt; findAll(); List&lt;T&gt; findAll(Sort sort); List&lt;T&gt; findAllById(Iterable&lt;ID&gt; ids); &lt;S extends T&gt; List&lt;S&gt; saveAll(Iterable&lt;S&gt; entities); void flush(); &lt;S extends T&gt; S saveAndFlush(S entity); void deleteInBatch(Iterable&lt;T&gt; entities); void deleteAllInBatch(); T getOne(ID id); &lt;S extends T&gt; List&lt;S&gt; findAll(Example&lt;S&gt; example); &lt;S extends T&gt; List&lt;S&gt; findAll(Example&lt;S&gt; example, Sort sort);&#125; JpaRepository&lt;T, ID&gt;说明：T： 关联的实体对象ID：为关联实体的Id类型 Sava方法实现：sava()会通过id判断插入的对象是否为新的，如果为新插入，否则更新： 123456789@Transactionalpublic &lt;S extends T&gt; S save(S entity) &#123; if (entityInformation.isNew(entity)) &#123; em.persist(entity); return entity; &#125; else &#123; return em.merge(entity); &#125;&#125; 在使用save方法时，Entity属性不能为null，动态插入时需要在对应实体加@DynamicInsert或在对应字段加@Column(insertable = false)，如果我们不想让mtime插入或手动更新，可以如下使用： 12@Column(insertable = false,updatable = false)private Timestamp mtime;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://www.xxzp.tech/tags/java/"},{"name":"JPA","slug":"JPA","permalink":"http://www.xxzp.tech/tags/JPA/"},{"name":"spring boot","slug":"spring-boot","permalink":"http://www.xxzp.tech/tags/spring-boot/"}]}]}