<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-124198848-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  
  <title>分代 GC 分析 | Ares</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1. 概述分代回收的基本思路，大部分对象都会在短时间内成为垃圾，而经过一定时间依然存活的对象往往存活时间较长。Java程序运行的过程中，会产生大量的对象，其中一些全局对象和连接池相关的对象生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的局部变量而且占大部分，这些对象生命周期会比较短。针对这样的特性，对于生命周期比较短的对象存放在特定的内存区域，重点扫描回收这样可以更有效的回收非活对象。">
<meta name="keywords" content="jvm,gc">
<meta property="og:type" content="article">
<meta property="og:title" content="分代 GC 分析">
<meta property="og:url" content="http://www.xxzp.tech/2018/09/02/分代GC算法分析/index.html">
<meta property="og:site_name" content="Ares">
<meta property="og:description" content="1. 概述分代回收的基本思路，大部分对象都会在短时间内成为垃圾，而经过一定时间依然存活的对象往往存活时间较长。Java程序运行的过程中，会产生大量的对象，其中一些全局对象和连接池相关的对象生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的局部变量而且占大部分，这些对象生命周期会比较短。针对这样的特性，对于生命周期比较短的对象存放在特定的内存区域，重点扫描回收这样可以更有效的回收非活对象。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://www.xxzp.tech/img/edenTenured.png">
<meta property="og:updated_time" content="2018-09-02T13:44:03.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="分代 GC 分析">
<meta name="twitter:description" content="1. 概述分代回收的基本思路，大部分对象都会在短时间内成为垃圾，而经过一定时间依然存活的对象往往存活时间较长。Java程序运行的过程中，会产生大量的对象，其中一些全局对象和连接池相关的对象生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的局部变量而且占大部分，这些对象生命周期会比较短。针对这样的特性，对于生命周期比较短的对象存放在特定的内存区域，重点扫描回收这样可以更有效的回收非活对象。">
<meta name="twitter:image" content="http://www.xxzp.tech/img/edenTenured.png">
  
    <link rel="alternate" href="/atom.xml" title="Ares" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Ares</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">技术不容易，一步一步往前走</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://www.xxzp.tech"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-分代GC算法分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/02/分代GC算法分析/" class="article-date">
  <time datetime="2018-09-01T16:00:00.000Z" itemprop="datePublished">2018-09-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/gc/">gc</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      分代 GC 分析
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>分代回收的基本思路，大部分对象都会在短时间内成为垃圾，而经过一定时间依然存活的对象往往存活时间较长。Java程序运行的过程中，会产生大量的对象，其中一些全局对象和连接池相关的对象生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的局部变量而且占大部分，这些对象生命周期会比较短。针对这样的特性，对于生命周期比较短的对象存放在特定的内存区域，重点扫描回收这样可以更有效的回收非活对象。<br><a id="more"></a><br>分代回收策略中，对象按照生成时间进行分代，刚刚生成不久的年轻对象划为新生代（Young gen-eration），而存活了较长时间的对象划为老生代（Old generation）。采用分代回收策略，可以对新生代和老年代采用不同的回收算法，在新生代，对象“朝生夕死”。gc一般采取复制算法，因为此算法的突出特点就是只关心哪些需要被复制，可达性分析只用标记和复制很少的存活对象，而根据老年代对象的特点，一般采用标记-清理策略的算法。采用分代策略，gc时进行可达性分析的范围能大大降低，在分代回收中，新生代的规模比老年代小，回收频率也要高，显然新生代gc的时候不能去遍历老年代。</p>
<h2 id="2-jvm-分代策略"><a href="#2-jvm-分代策略" class="headerlink" title="2. jvm 分代策略"></a>2. jvm 分代策略</h2><p>jvm 中分代策略如下图；</p>
<p><img src="/img/edenTenured.png" alt=""></p>
<h3 id="2-1-新生代"><a href="#2-1-新生代" class="headerlink" title="2.1 新生代"></a>2.1 新生代</h3><p>新生代有划分为Eden、From Survivor和To Survivor三个部分，他们对应的内存空间的大小比例为 8:1:1，为对象分配内存的时候，首先使用Eden空间，经过GC后，没有被回收的会首先进入 From 区域，任何时候，都会保持一个 Survivorq 区域（From 或 To）完全空闲，也就是说新生代的内存利用率最大为90%。</p>
<p>From 和To 两个区域会根据GC的实际情况，进行互换，将 From 区域中的对象全部复制到 To区域中，或者反过来，将 To 区域中的对象全部复制到 From 区域中。一般 new 一个对象时，它会在 Eden 区中划出一块作为存储对象的内存，由于堆空间是线程共享的，因此直接在这里边划空间是需要进行同步的。</p>
<h3 id="2-2-老年代"><a href="#2-2-老年代" class="headerlink" title="2.2 老年代"></a>2.2 老年代</h3><p>对象经过多次GC以后，经过Eden Space，多次经过 From 和 To 之后进入年老代，而且对象在年老代的存活时间比较长，如果进行使用复制算法来进行GC，需要移动大量的对象，导致效率很低。所以，年老代适合使用标记-清除算法，需要被GC的对象很少，那么标记的对象就很少，在对标记的对象进行回收，效率就会很高。</p>
<h2 id="3-内存分配过程"><a href="#3-内存分配过程" class="headerlink" title="3. 内存分配过程"></a>3. 内存分配过程</h2><ul>
<li><p>对象优先在Eden分配</p>
</li>
<li><p>大对象直接进入老年代</p>
</li>
<li><p>长期存活的对象将进入老年代：对象在Eden出生并经过第一次的Minor GC后仍然存活，并且能被Surivivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Surivivor区中每熬过一次MinorGC，年龄就增加一岁，当它的年龄增加到一定程度（默认15岁），就会被晋升到老年代中。</p>
</li>
<li><p>动态对象年龄判定：如果Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于改年龄的对象就可以直接进入老年代，无需等到最大年龄阀值。</p>
</li>
<li><p>空间分配担保：在发生Minor GC之前，虚拟机会先检查老年大最大可用连续空间是否大于新生代所有对象总空间，如果条件成立，那么Minor GC是安全的。如果不成立，则虚拟机会检查HandlePrimotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，则尝试一次Minor GC，尽管这次Minor GC是有风险的。如果小于，或者HandlePrimotionFailure设置不允许冒险，那么这时也要改为进行一次Full GC。</p>
</li>
</ul>
<h2 id="4-gc-收集器与策略"><a href="#4-gc-收集器与策略" class="headerlink" title="4. gc 收集器与策略"></a>4. gc 收集器与策略</h2><h3 id="4-1-垃圾收集器"><a href="#4-1-垃圾收集器" class="headerlink" title="4.1 垃圾收集器"></a>4.1 垃圾收集器</h3><p><strong>Serial收集器：</strong>单线程收集器，新生代采用复制算法，老年代采用标记-整理，会暂停所有用户线程</p>
<p><strong>ParNew收集器：</strong>多线程收集器，新生代采用复制算法，老年代采用标记-整理，会暂停所有用户线程。可以与CMS收集器配合工作</p>
<p><strong>Serial Old 收集器：</strong>Serial收集器的老年代版本，单线程收集器，采用的是“标记–整理”算法</p>
<p><strong>Parallel Old 收集器：</strong>Parallel收集器的老年代版本，多线程收集器，采用的是“标记–整理”算法。在注重吞吐量以及CPU资源敏感的场合，可以考虑Parallel Scavenge和 Parallel Old 组合。</p>
<p><strong>CMS 收集器：</strong>并发收集器，低停顿。经过4个步骤：①初始标记②并发标记③重新标记④并发清除。采用“标记–清除算法”。不足：会产生大量空间碎片。①、③仍然需要stop the World</p>
<p><strong>G1收集器：</strong>G1将堆拆成一系列的分区，这样在一个时间段内，大部分的垃圾收集操作就只是在一个分区内执行，而不是整个堆或整个（老年）代。</p>
<h3 id="4-2-gc-策略"><a href="#4-2-gc-策略" class="headerlink" title="4.2 gc 策略"></a>4.2 gc 策略</h3><p><strong>默认策略：</strong>JVM针对上述不同的分代区域，默认使用的 GC 策略如下：</p>
<table>
<thead>
<tr>
<th>运行模式</th>
<th>新生代垃GC策略</th>
<th>年老代GC策略</th>
</tr>
</thead>
<tbody>
<tr>
<td>Client</td>
<td>Serial GC</td>
<td>Serial Old GC</td>
</tr>
<tr>
<td>Server</td>
<td>Parallel Scavenge  GC</td>
<td>Serial Old GC</td>
</tr>
</tbody>
</table>
<p>平时我们运行Java程序，没有指定任何选项的时候，默认根据上面的GC策略搭配进行GC。</p>
<p><strong>gc 策略组合：</strong>JVM调优的过程中，并非任何一种新生代GC策略都可以和另一种年老代GC策略进行配合工作，如下是常用使用组合：</p>
<table>
<thead>
<tr>
<th style="text-align:center">策略</th>
<th>新生代</th>
<th>年老代</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td>Serial</td>
<td>Serial Old</td>
<td>Serial和Serial Old都是单线程进行GC，特点就是GC时暂停所有应用线程</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td>Serial</td>
<td>CMS+Serial Old</td>
<td>CMS是并发GC，实现GC线程和应用线程并发工作，不需要暂停所有应用线程, 当CMS进行GC失败时，会自动使用Serial Old策略进行GC</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td>ParNew</td>
<td>CMS</td>
<td>使用-XX:+UseParNewGC选项来开启，ParNew是Serial的并行版本，可以指定GC线程数，默认GC线程数为CPU的数量，可以使用-XX:ParallelGCThreads选项指定GC的线程数，如果指定了选项-XX:+UseConcMarkSweepGC选项，则新生代默认使用ParNew GC策略</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td>ParNew</td>
<td>Serial Old</td>
<td>使用-XX:+UseParNewGC选项来开启。新生代使用ParNew GC策略，年老代默认使用Serial Old GC策略</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td>Parallel Scavenge</td>
<td>Serial Old</td>
<td>Parallel Scavenge策略主要是关注一个可控的吞吐量：应用程序运行时间 / (应用程序运行时间 + GC时间)，适用于后台持久运行的应用程序，而不适用于交互较多的应用程序</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td>Parallel Scavenge</td>
<td>Parallel Old</td>
<td>Parallel Old是Serial Old的并行版本</td>
</tr>
</tbody>
</table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.xxzp.tech/2018/09/02/分代GC算法分析/" data-id="cjtmnge5100125esyw72ctjh3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/gc/">gc</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jvm/">jvm</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/09/02/CMS 深入/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          CMS 深入分析
        
      </div>
    </a>
  
  
    <a href="/2018/09/01/GC 算法概述/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">GC 初步</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/gc/">gc</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/java/redis/">redis</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/java/redis/spring-boot/">spring boot</a></li></ul></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JPA/">JPA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gc/">gc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jvm/">jvm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lambda/">lambda</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-boot/">spring boot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/并发/">并发</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/JPA/" style="font-size: 12.5px;">JPA</a> <a href="/tags/gc/" style="font-size: 15px;">gc</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/jvm/" style="font-size: 17.5px;">jvm</a> <a href="/tags/lambda/" style="font-size: 12.5px;">lambda</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/spring-boot/" style="font-size: 12.5px;">spring boot</a> <a href="/tags/并发/" style="font-size: 15px;">并发</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/10/10/java服务线上问题排查思路/">java服务线上问题排查思路</a>
          </li>
        
          <li>
            <a href="/2018/09/25/java常用命令/">jvm 自带命令工具</a>
          </li>
        
          <li>
            <a href="/2018/09/05/redis 分布式锁实现/">redis 分布式锁实现</a>
          </li>
        
          <li>
            <a href="/2018/09/02/CMS 深入/">CMS 深入分析</a>
          </li>
        
          <li>
            <a href="/2018/09/02/分代GC算法分析/">分代 GC 分析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Ares<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>